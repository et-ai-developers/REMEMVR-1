#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step03
Step Name: Test 2 - Piecewise vs Continuous Comparison
RQ: results/ch6/6.1.2
Generated: 2025-12-10

PURPOSE:
Test for two-phase pattern by comparing piecewise model (separate Early/Late slopes)
to continuous linear model via AIC. If piecewise model has substantially better fit
(delta AIC > 2), it provides evidence for two-phase forgetting pattern.

EXPECTED INPUTS:
  - data/step01_piecewise_input.csv
    Columns: ['UID', 'TSVR_hours', 'Time_Early', 'Time_Late', 'theta_confidence']
    Format: CSV with UTF-8 encoding
    Expected rows: 400

EXPECTED OUTPUTS:
  - data/step03_piecewise_comparison.csv
    Columns: ['model', 'AIC', 'delta_AIC', 'piecewise_preferred']
    Format: CSV with UTF-8 encoding
    Expected rows: 3 (Continuous, Piecewise, Comparison summary)
    Description: AIC comparison between continuous and piecewise models

VALIDATION CRITERIA:
  - Both models converged (continuous AND piecewise)
  - AIC values extracted and reasonable (typically 500-1500 for N=400)
  - Delta AIC computed correctly (AIC_continuous - AIC_piecewise)
  - Comparison conclusion documented (piecewise_preferred bool)
  - No NaN values in comparison table

g_code REASONING:
- Approach: Fit two competing models (continuous linear vs piecewise), compare via AIC
- Why this approach: AIC comparison quantifies evidence for two-phase pattern
- Data flow: Same data fitted with different time specifications
- Expected performance: ~60 seconds (two LMM fits with random slopes)

IMPLEMENTATION NOTES:
- Analysis tool: fit_lmm_trajectory_tsvr from tools.analysis_lmm (called twice)
- Validation tool: validate_lmm_convergence from tools.validation
- Parameters: Both models use random slopes, ML estimation (REML=False)
- Burnham & Anderson threshold: delta AIC > 2 = substantial evidence
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import analysis and validation tools
from tools.analysis_lmm import fit_lmm_trajectory_tsvr
from tools.validation import validate_lmm_convergence

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/ch6/6.1.2
LOG_FILE = RQ_DIR / "logs" / "step03_compare_piecewise_models.log"

# Input/output paths
INPUT_FILE = RQ_DIR / "data" / "step01_piecewise_input.csv"
OUTPUT_FILE = RQ_DIR / "data" / "step03_piecewise_comparison.csv"

# LMM formulas
CONTINUOUS_FORMULA = "theta_confidence ~ TSVR_hours"
PIECEWISE_FORMULA = "theta_confidence ~ Time_Early + Time_Late"
RE_FORMULA = "~TSVR_hours"

# Burnham & Anderson threshold
DELTA_AIC_THRESHOLD = 2.0

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 03: Compare Piecewise Models")

        # =========================================================================
        # STEP 1: Load Input Data
        # =========================================================================
        # Expected: Piecewise variables from Step 1
        # Purpose: Base data with Time_Early and Time_Late for piecewise regression

        log(f"[LOAD] Loading input data from {INPUT_FILE.name}...")
        piecewise_data = pd.read_csv(INPUT_FILE, encoding='utf-8')
        log(f"[LOADED] {INPUT_FILE.name} ({len(piecewise_data)} rows, {len(piecewise_data.columns)} cols)")
        log(f"[INFO] Theta range: [{piecewise_data['theta_confidence'].min():.3f}, {piecewise_data['theta_confidence'].max():.3f}]")
        log(f"[INFO] Segment distribution: Early={sum(piecewise_data['Segment']=='Early')}, Late={sum(piecewise_data['Segment']=='Late')}")

        # =========================================================================
        # STEP 2: Fit Continuous Model
        # =========================================================================
        # Tool: fit_lmm_trajectory_tsvr
        # What it does: Fits linear LMM with single TSVR_hours slope
        # Expected output: MixedLMResults for continuous model

        log(f"[ANALYSIS] Fitting continuous model...")
        log(f"[INFO] Formula: {CONTINUOUS_FORMULA}")
        log(f"[INFO] Random effects: {RE_FORMULA}")

        continuous_model = fit_lmm_trajectory_tsvr(
            theta_scores=piecewise_data,
            tsvr_data=piecewise_data,
            formula=CONTINUOUS_FORMULA,
            groups='UID',
            re_formula=RE_FORMULA,
            reml=False
        )

        log("[DONE] Continuous model fitted")
        log(f"[INFO] Continuous AIC: {continuous_model.aic:.2f}")

        # Validate continuous model convergence
        log("[VALIDATION] Checking continuous model convergence...")
        val_continuous = validate_lmm_convergence(lmm_result=continuous_model)
        if not val_continuous['converged']:
            log(f"[VALIDATION] FAIL - Continuous model did not converge: {val_continuous['message']}")
            raise ValueError(f"Continuous model convergence failed: {val_continuous['message']}")
        else:
            log("[VALIDATION] PASS - Continuous model converged")

        # =========================================================================
        # STEP 3: Fit Piecewise Model
        # =========================================================================
        # Tool: fit_lmm_trajectory_tsvr
        # What it does: Fits LMM with separate Early/Late slopes
        # Expected output: MixedLMResults for piecewise model

        log(f"[ANALYSIS] Fitting piecewise model...")
        log(f"[INFO] Formula: {PIECEWISE_FORMULA}")
        log(f"[INFO] Random effects: {RE_FORMULA}")

        piecewise_model = fit_lmm_trajectory_tsvr(
            theta_scores=piecewise_data,
            tsvr_data=piecewise_data,
            formula=PIECEWISE_FORMULA,
            groups='UID',
            re_formula=RE_FORMULA,
            reml=False
        )

        log("[DONE] Piecewise model fitted")
        log(f"[INFO] Piecewise AIC: {piecewise_model.aic:.2f}")

        # Validate piecewise model convergence
        log("[VALIDATION] Checking piecewise model convergence...")
        val_piecewise = validate_lmm_convergence(lmm_result=piecewise_model)
        if not val_piecewise['converged']:
            log(f"[VALIDATION] FAIL - Piecewise model did not converge: {val_piecewise['message']}")
            raise ValueError(f"Piecewise model convergence failed: {val_piecewise['message']}")
        else:
            log("[VALIDATION] PASS - Piecewise model converged")

        # =========================================================================
        # STEP 4: Compute AIC Comparison
        # =========================================================================
        # Delta AIC = AIC_continuous - AIC_piecewise
        # Positive delta = piecewise preferred

        log("[ANALYSIS] Computing AIC comparison...")

        aic_continuous = continuous_model.aic
        aic_piecewise = piecewise_model.aic
        delta_aic = aic_continuous - aic_piecewise
        piecewise_preferred = delta_aic > DELTA_AIC_THRESHOLD

        log(f"[RESULT] Delta AIC: {delta_aic:.2f} (AIC_continuous - AIC_piecewise)")
        log(f"[RESULT] Threshold: {DELTA_AIC_THRESHOLD} (Burnham & Anderson)")

        if piecewise_preferred:
            log(f"[RESULT] Piecewise model PREFERRED (delta AIC > {DELTA_AIC_THRESHOLD}) -> Two-phase pattern SUPPORTED")
        else:
            log(f"[RESULT] Continuous model NOT substantially worse (delta AIC <= {DELTA_AIC_THRESHOLD}) -> Two-phase pattern NOT supported by AIC test")

        # Create comparison DataFrame
        comparison_df = pd.DataFrame({
            'model': ['Continuous', 'Piecewise', 'Comparison'],
            'AIC': [aic_continuous, aic_piecewise, np.nan],
            'delta_AIC': [np.nan, np.nan, delta_aic],
            'piecewise_preferred': [np.nan, np.nan, piecewise_preferred]
        })

        log("[DONE] AIC comparison computed")

        # =========================================================================
        # STEP 5: Save Comparison Results
        # =========================================================================
        # Output: data/step03_piecewise_comparison.csv
        # Contains: AIC values, delta AIC, preference conclusion

        log(f"[SAVE] Saving AIC comparison to {OUTPUT_FILE.name}...")
        comparison_df.to_csv(OUTPUT_FILE, index=False, encoding='utf-8')
        log(f"[SAVED] {OUTPUT_FILE.name} ({len(comparison_df)} rows)")

        # =========================================================================
        # STEP 6: Run Validation
        # =========================================================================
        # Additional custom validations beyond convergence

        log("[VALIDATION] Running custom comparison checks...")

        # Check AIC values are reasonable (not negative, not extremely large)
        if aic_continuous < 0 or aic_piecewise < 0:
            log("[VALIDATION] FAIL - Negative AIC values found")
            raise ValueError("Invalid AIC values (negative)")
        else:
            log("[VALIDATION] PASS - AIC values non-negative")

        if aic_continuous > 10000 or aic_piecewise > 10000:
            log("[VALIDATION] WARNING - Extremely large AIC values (>10000)")
        else:
            log("[VALIDATION] PASS - AIC values in reasonable range")

        # Check delta AIC computed correctly
        computed_delta = aic_continuous - aic_piecewise
        if abs(computed_delta - delta_aic) > 0.01:
            log(f"[VALIDATION] FAIL - Delta AIC mismatch (computed: {computed_delta:.2f}, stored: {delta_aic:.2f})")
            raise ValueError("Delta AIC computation error")
        else:
            log("[VALIDATION] PASS - Delta AIC computed correctly")

        # Check no NaN values in key columns (except expected ones)
        if pd.isna(aic_continuous) or pd.isna(aic_piecewise) or pd.isna(delta_aic):
            log("[VALIDATION] FAIL - Unexpected NaN values in comparison results")
            raise ValueError("NaN values found in AIC comparison")
        else:
            log("[VALIDATION] PASS - No unexpected NaN values")

        # Check piecewise_preferred is boolean
        if not isinstance(piecewise_preferred, (bool, np.bool_)):
            log(f"[VALIDATION] FAIL - piecewise_preferred is not boolean: {type(piecewise_preferred)}")
            raise ValueError("piecewise_preferred should be boolean")
        else:
            log("[VALIDATION] PASS - piecewise_preferred is boolean")

        log("[SUCCESS] Step 03 complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
