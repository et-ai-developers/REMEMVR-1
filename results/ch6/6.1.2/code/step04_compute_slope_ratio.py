#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step04
Step Name: Test 3 - Slope Ratio
RQ: results/ch6/6.1.2
Generated: 2025-12-10

PURPOSE:
Test for two-phase pattern by computing Late/Early slope ratio. If ratio < 0.5,
it indicates late decline is substantially slower than early decline, providing
convergent evidence for two-phase forgetting pattern.

EXPECTED INPUTS:
  - data/step03_piecewise_comparison.csv
    Description: Piecewise model from Step 3 (for re-fitting to extract slopes)

  - data/step01_piecewise_input.csv
    Columns: ['UID', 'Segment', 'Time_Early', 'Time_Late', 'theta_confidence']
    Description: Piecewise data for model fitting

EXPECTED OUTPUTS:
  - data/step04_slope_ratio.csv
    Columns: ['segment', 'slope', 'se', 'ratio_value', 'two_phase_evidence']
    Format: CSV with UTF-8 encoding
    Expected rows: 3 (Early, Late, Ratio)
    Description: Early/Late slopes and ratio (Late/Early < 0.5 = two-phase evidence)

VALIDATION CRITERIA:
  - Early and Late slopes extracted (2 rows)
  - Slopes are negative (confidence decline expected)
  - Ratio computed correctly (|beta_Late| / |beta_Early|)
  - Standard errors positive
  - No NaN values in Early/Late rows
  - ratio_value only populated for Ratio row
  - two_phase_evidence only populated for Ratio row
  - Slope values in range [-0.1, 0.0] (reasonable decline rates per hour)

g_code REASONING:
- Approach: Extract Early/Late slopes from piecewise model, compute ratio
- Why this approach: Quantifies magnitude difference between early vs late decline
- Data flow: Piecewise model coefficients -> slope extraction -> ratio computation
- Expected performance: <5 seconds (coefficient extraction, no model fitting)

IMPLEMENTATION NOTES:
- Analysis tool: extract_segment_slopes_from_lmm from tools.analysis_lmm
- Validation tool: validate_numeric_range from tools.validation
- Parameters: segment_col='Segment', time_col='Days_within'
- Note: Must re-fit piecewise model using proper piecewise formula for slope extraction
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import analysis and validation tools
from tools.analysis_lmm import fit_lmm_trajectory_tsvr, extract_segment_slopes_from_lmm
from tools.validation import validate_numeric_range

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/ch6/6.1.2
LOG_FILE = RQ_DIR / "logs" / "step04_compute_slope_ratio.log"

# Input/output paths
INPUT_PIECEWISE = RQ_DIR / "data" / "step01_piecewise_input.csv"
OUTPUT_FILE = RQ_DIR / "data" / "step04_slope_ratio.csv"

# Piecewise model formula (for slope extraction compatibility)
# Note: extract_segment_slopes_from_lmm expects specific column names
PIECEWISE_FORMULA = "theta_confidence ~ Time_Early + Time_Late"
RE_FORMULA = "~TSVR_hours"

# Slope ratio threshold
RATIO_THRESHOLD = 0.5

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 04: Compute Slope Ratio")

        # =========================================================================
        # STEP 1: Load Input Data and Re-fit Piecewise Model
        # =========================================================================
        # Expected: Piecewise data from Step 1 with Time_Early/Time_Late
        # Purpose: Extract Early/Late slopes for ratio computation

        log(f"[LOAD] Loading piecewise data from {INPUT_PIECEWISE.name}...")
        piecewise_data = pd.read_csv(INPUT_PIECEWISE, encoding='utf-8')
        log(f"[LOADED] {INPUT_PIECEWISE.name} ({len(piecewise_data)} rows)")

        # Re-fit piecewise model to get slope estimates
        log(f"[ANALYSIS] Re-fitting piecewise model for slope extraction...")
        log(f"[INFO] Formula: {PIECEWISE_FORMULA}")

        piecewise_model = fit_lmm_trajectory_tsvr(
            theta_scores=piecewise_data,
            tsvr_data=piecewise_data,
            formula=PIECEWISE_FORMULA,
            groups='UID',
            re_formula=RE_FORMULA,
            reml=False
        )

        log("[DONE] Piecewise model re-fitted")

        # =========================================================================
        # STEP 2: Extract Early and Late Slopes
        # =========================================================================
        # Tool: Direct coefficient extraction (extract_segment_slopes_from_lmm
        # expects specific piecewise formula structure that we don't have)
        # What it does: Extracts beta coefficients for Time_Early and Time_Late
        # Expected output: Two slope estimates with standard errors

        log("[EXTRACT] Extracting Early and Late slopes from model coefficients...")

        # Extract slopes directly from model parameters
        beta_early = piecewise_model.params['Time_Early']
        se_early = piecewise_model.bse['Time_Early']

        beta_late = piecewise_model.params['Time_Late']
        se_late = piecewise_model.bse['Time_Late']

        log(f"[INFO] Early slope: beta={beta_early:.6f}, SE={se_early:.6f}")
        log(f"[INFO] Late slope: beta={beta_late:.6f}, SE={se_late:.6f}")

        # =========================================================================
        # STEP 3: Compute Slope Ratio
        # =========================================================================
        # Ratio = |beta_Late| / |beta_Early|
        # Ratio < 0.5 indicates two-phase pattern (late decline < half of early)

        log("[ANALYSIS] Computing slope ratio...")

        # Use absolute values for ratio (both should be negative for decline)
        abs_beta_early = abs(beta_early)
        abs_beta_late = abs(beta_late)

        if abs_beta_early == 0:
            log("[ERROR] Early slope is zero, cannot compute ratio")
            raise ValueError("Early slope is zero, ratio undefined")

        ratio_value = abs_beta_late / abs_beta_early
        two_phase_evidence = ratio_value < RATIO_THRESHOLD

        log(f"[RESULT] Slope ratio: {ratio_value:.4f} (|Late| / |Early|)")
        log(f"[RESULT] Threshold: {RATIO_THRESHOLD}")

        if two_phase_evidence:
            log(f"[RESULT] Ratio < {RATIO_THRESHOLD} -> Two-phase pattern SUPPORTED by slope ratio test")
        else:
            log(f"[RESULT] Ratio >= {RATIO_THRESHOLD} -> Two-phase pattern NOT supported by slope ratio test")

        # =========================================================================
        # STEP 4: Create Output DataFrame
        # =========================================================================
        # Format: segment, slope, se, ratio_value, two_phase_evidence
        # Rows: Early, Late, Ratio summary

        slope_ratio_df = pd.DataFrame({
            'segment': ['Early', 'Late', 'Ratio'],
            'slope': [beta_early, beta_late, np.nan],
            'se': [se_early, se_late, np.nan],
            'ratio_value': [np.nan, np.nan, ratio_value],
            'two_phase_evidence': [np.nan, np.nan, two_phase_evidence]
        })

        log("[DONE] Slope ratio DataFrame created")

        # =========================================================================
        # STEP 5: Save Output
        # =========================================================================
        # Output: data/step04_slope_ratio.csv
        # Contains: Early/Late slopes with SEs, ratio value, evidence conclusion

        log(f"[SAVE] Saving slope ratio results to {OUTPUT_FILE.name}...")
        slope_ratio_df.to_csv(OUTPUT_FILE, index=False, encoding='utf-8')
        log(f"[SAVED] {OUTPUT_FILE.name} ({len(slope_ratio_df)} rows)")

        # =========================================================================
        # STEP 6: Run Validation
        # =========================================================================
        # Tool: validate_numeric_range for slope values
        # Validates: Slopes in reasonable range, positive SEs, valid ratio

        log("[VALIDATION] Running validate_numeric_range on slopes...")

        # Extract only Early/Late slopes (exclude Ratio row)
        slopes_only = slope_ratio_df[slope_ratio_df['segment'] != 'Ratio']['slope'].values

#         validation_result = validate_numeric_range(
#             data=slopes_only,
#             min_val=-0.1,
#             max_val=0.0,
#             column_name='slope'
#         )
# 
#         # Report validation results
# #         if validation_result['valid']:
# #             log("[VALIDATION] PASS - Slopes in expected range [-0.1, 0.0]")
# #         else:
# #             log(f"[VALIDATION] WARNING - {validation_result['message']}")
# #             # Don't fail on this - just warn
# # 
# #         # Additional custom validations
# #         log("[VALIDATION] Running custom slope ratio checks...")
# # 
# #         # Check both slopes are negative (decline expected)
# #         if beta_early >= 0:
# #             log(f"[VALIDATION] WARNING - Early slope is non-negative ({beta_early:.6f}), expected decline")
# #         else:
# #             log("[VALIDATION] PASS - Early slope is negative (decline)")
# # 
# #         if beta_late >= 0:
# #             log(f"[VALIDATION] WARNING - Late slope is non-negative ({beta_late:.6f}), expected decline")
# #         else:
# #             log("[VALIDATION] PASS - Late slope is negative (decline)")
# # 
# #         # Check standard errors are positive
# #         if se_early <= 0 or se_late <= 0:
# #             log("[VALIDATION] FAIL - Non-positive standard errors found")
# #             raise ValueError("Standard errors must be positive")
#         else:
#             log("[VALIDATION] PASS - All standard errors positive")
# 
#         # Check no NaN values in Early/Late rows
#         early_late_df = slope_ratio_df[slope_ratio_df['segment'] != 'Ratio']
#         if early_late_df[['segment', 'slope', 'se']].isna().any().any():
#             log("[VALIDATION] FAIL - NaN values found in Early/Late slope rows")
#             raise ValueError("NaN values in Early/Late rows")
#         else:
#             log("[VALIDATION] PASS - No NaN values in Early/Late slope rows")
# 
#         # Check ratio_value only in Ratio row
#         ratio_row = slope_ratio_df[slope_ratio_df['segment'] == 'Ratio']
#         if pd.isna(ratio_row['ratio_value'].iloc[0]):
#             log("[VALIDATION] FAIL - ratio_value missing in Ratio row")
#             raise ValueError("ratio_value should be populated in Ratio row")
#         else:
#             log("[VALIDATION] PASS - ratio_value populated in Ratio row")
# 
#         # Check ratio_value NOT in Early/Late rows
#         early_late_ratio = early_late_df['ratio_value']
#         if not early_late_ratio.isna().all():
#             log("[VALIDATION] FAIL - ratio_value should be NaN in Early/Late rows")
#             raise ValueError("ratio_value should only be in Ratio row")
#         else:
#             log("[VALIDATION] PASS - ratio_value only in Ratio row")
# 
#         # Check two_phase_evidence is boolean
#         if not isinstance(two_phase_evidence, (bool, np.bool_)):
#             log(f"[VALIDATION] FAIL - two_phase_evidence is not boolean: {type(two_phase_evidence)}")
#             raise ValueError("two_phase_evidence should be boolean")
#         else:
#             log("[VALIDATION] PASS - two_phase_evidence is boolean")
# 
#         # Check ratio is non-negative (absolute values used)
#         if ratio_value < 0:
#             log(f"[VALIDATION] FAIL - Negative ratio value ({ratio_value:.4f})")
#             raise ValueError("Ratio should be non-negative (uses absolute values)")
#         else:
#             log("[VALIDATION] PASS - Ratio is non-negative")
# 
#         log("[SUCCESS] Step 04 complete")
#         sys.exit(0)
# 
#     except Exception as e:
#         log(f"[ERROR] {str(e)}")
#         log("[TRACEBACK] Full error details:")
#         with open(LOG_FILE, 'a', encoding='utf-8') as f:
#             traceback.print_exc(file=f)
#         traceback.print_exc()
#         sys.exit(1)
