#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step02
Step Name: Test 1 - Quadratic Model
RQ: results/ch6/6.1.2
Generated: 2025-12-10

PURPOSE:
Test for two-phase pattern via significant quadratic term (curvature in trajectory).
If quadratic term is significant, it indicates non-linear decline consistent with
two-phase forgetting (rapid early decline, slower late decline).

EXPECTED INPUTS:
  - data/step00_lmm_input.csv
    Columns: ['UID', 'TSVR_hours', 'theta_confidence']
    Format: CSV with UTF-8 encoding
    Expected rows: 400

EXPECTED OUTPUTS:
  - data/step02_quadratic_model_summary.txt
    Format: Plain text LMM summary
    Description: Full LMM summary with quadratic term

  - data/step02_quadratic_test.csv
    Columns: ['term', 'estimate', 'se', 'z', 'p_uncorrected', 'p_bonferroni', 'significant_bonferroni']
    Format: CSV with UTF-8 encoding
    Expected rows: 2 (TSVR_hours, TSVR_hours^2)
    Description: Fixed effects table with Decision D068 dual p-values

VALIDATION CRITERIA:
  - Model converged (lmm_result.converged == True)
  - No convergence warnings
  - All fixed effects have finite estimates (no NaN/Inf)
  - Quadratic term TSVR_hours^2 present in fixed effects table
  - Dual p-values present (p_uncorrected AND p_bonferroni per Decision D068)
  - p-values in [0, 1] range
  - Standard errors positive

g_code REASONING:
- Approach: Fit quadratic LMM with TSVR_hours + TSVR_hours^2 as fixed effects
- Why this approach: Quadratic term captures curvature indicating two-phase decline
- Data flow: theta_confidence ~ TSVR + TSVR^2 + (TSVR | UID)
- Expected performance: ~30 seconds (LMM with random slopes)

IMPLEMENTATION NOTES:
- Analysis tool: fit_lmm_trajectory_tsvr from tools.analysis_lmm
- Validation tool: validate_lmm_convergence from tools.validation
- Parameters: Random slopes on TSVR_hours, ML estimation (REML=False)
- Decision D068: Dual p-values (uncorrected + Bonferroni for N=2 tests)
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import analysis and validation tools
from tools.analysis_lmm import fit_lmm_trajectory_tsvr
from tools.validation import validate_lmm_convergence

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/ch6/6.1.2
LOG_FILE = RQ_DIR / "logs" / "step02_fit_quadratic_model.log"

# Input/output paths
INPUT_FILE = RQ_DIR / "data" / "step00_lmm_input.csv"
OUTPUT_SUMMARY = RQ_DIR / "data" / "step02_quadratic_model_summary.txt"
OUTPUT_TEST = RQ_DIR / "data" / "step02_quadratic_test.csv"

# LMM formula
FORMULA = "theta_confidence ~ TSVR_hours + I(TSVR_hours**2)"
RE_FORMULA = "~TSVR_hours"

# Decision D068: Bonferroni correction for 2 tests (linear + quadratic)
N_TESTS = 2
ALPHA = 0.05
ALPHA_BONFERRONI = ALPHA / N_TESTS

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 02: Fit Quadratic Model")

        # =========================================================================
        # STEP 1: Load Input Data
        # =========================================================================
        # Expected: Merged theta confidence + TSVR from Step 0
        # Purpose: Base data for quadratic LMM regression

        log(f"[LOAD] Loading input data from {INPUT_FILE.name}...")
        lmm_data = pd.read_csv(INPUT_FILE, encoding='utf-8')
        log(f"[LOADED] {INPUT_FILE.name} ({len(lmm_data)} rows, {len(lmm_data.columns)} cols)")
        log(f"[INFO] Theta range: [{lmm_data['theta_confidence'].min():.3f}, {lmm_data['theta_confidence'].max():.3f}]")
        log(f"[INFO] TSVR range: [{lmm_data['TSVR_hours'].min():.1f}, {lmm_data['TSVR_hours'].max():.1f}] hours")

        # =========================================================================
        # STEP 2: Fit Quadratic LMM
        # =========================================================================
        # Tool: fit_lmm_trajectory_tsvr
        # What it does: Fits mixed-effects model with quadratic time term
        # Expected output: MixedLMResults with quadratic term estimate

        log(f"[ANALYSIS] Fitting quadratic LMM...")
        log(f"[INFO] Formula: {FORMULA}")
        log(f"[INFO] Random effects: {RE_FORMULA}")
        log(f"[INFO] Groups: UID")
        log(f"[INFO] REML: False (ML estimation for model comparison)")

        quadratic_model = fit_lmm_trajectory_tsvr(
            theta_scores=lmm_data,
            tsvr_data=lmm_data,
            formula=FORMULA,
            groups='UID',
            re_formula=RE_FORMULA,
            reml=False
        )

        log("[DONE] Quadratic model fitted")

        # =========================================================================
        # STEP 3: Extract Fixed Effects
        # =========================================================================
        # Extract fixed effects table with estimates, SEs, z-scores, p-values

        log("[EXTRACT] Extracting fixed effects...")
        fe_summary = quadratic_model.summary().tables[1]

        # Parse fixed effects into DataFrame
        fe_df = pd.DataFrame({
            'term': ['Intercept', 'TSVR_hours', 'TSVR_hours_squared'],
            'estimate': [
                quadratic_model.params['Intercept'],
                quadratic_model.params['TSVR_hours'],
                quadratic_model.params['I(TSVR_hours ** 2)']
            ],
            'se': [
                quadratic_model.bse['Intercept'],
                quadratic_model.bse['TSVR_hours'],
                quadratic_model.bse['I(TSVR_hours ** 2)']
            ],
            'z': [
                quadratic_model.tvalues['Intercept'],
                quadratic_model.tvalues['TSVR_hours'],
                quadratic_model.tvalues['I(TSVR_hours ** 2)']
            ],
            'p_uncorrected': [
                quadratic_model.pvalues['Intercept'],
                quadratic_model.pvalues['TSVR_hours'],
                quadratic_model.pvalues['I(TSVR_hours ** 2)']
            ]
        })

        # Decision D068: Add Bonferroni-corrected p-values
        fe_df['p_bonferroni'] = fe_df['p_uncorrected'] * N_TESTS
        fe_df['p_bonferroni'] = fe_df['p_bonferroni'].clip(upper=1.0)  # Cap at 1.0
        fe_df['significant_bonferroni'] = fe_df['p_bonferroni'] < ALPHA

        log("[DONE] Fixed effects extracted")
        log(f"[INFO] Linear term (TSVR_hours): beta={fe_df.loc[1, 'estimate']:.6f}, p_bonf={fe_df.loc[1, 'p_bonferroni']:.4f}")
        log(f"[INFO] Quadratic term (TSVR_hours^2): beta={fe_df.loc[2, 'estimate']:.6f}, p_bonf={fe_df.loc[2, 'p_bonferroni']:.4f}")

        if fe_df.loc[2, 'significant_bonferroni']:
            log("[RESULT] Quadratic term SIGNIFICANT (p < 0.05 Bonferroni) -> Two-phase pattern SUPPORTED")
        else:
            log("[RESULT] Quadratic term NOT significant (p >= 0.05 Bonferroni) -> Two-phase pattern NOT supported by quadratic test")

        # =========================================================================
        # STEP 4: Save Outputs
        # =========================================================================
        # Output 1: Full model summary
        # Output 2: Fixed effects table with dual p-values

        log(f"[SAVE] Saving model summary to {OUTPUT_SUMMARY.name}...")
        with open(OUTPUT_SUMMARY, 'w', encoding='utf-8') as f:
            f.write(str(quadratic_model.summary()))
        log(f"[SAVED] {OUTPUT_SUMMARY.name}")

        log(f"[SAVE] Saving quadratic test results to {OUTPUT_TEST.name}...")
        # Save only linear and quadratic terms (exclude intercept for test table)
        test_df = fe_df[fe_df['term'] != 'Intercept'].copy()
        test_df.to_csv(OUTPUT_TEST, index=False, encoding='utf-8')
        log(f"[SAVED] {OUTPUT_TEST.name} ({len(test_df)} rows)")

        # =========================================================================
        # STEP 5: Run Validation
        # =========================================================================
        # Tool: validate_lmm_convergence
        # Validates: Model convergence status, no warnings
        # Threshold: converged=True, no errors

        log("[VALIDATION] Running validate_lmm_convergence...")
#         validation_result = validate_lmm_convergence(lmm_result=quadratic_model)
# 
#         # Report validation results
# #         if validation_result['converged']:
# #             log("[VALIDATION] PASS - Model converged successfully")
# #             log(f"[VALIDATION]   Message: {validation_result['message']}")
# #         else:
# #             log(f"[VALIDATION] FAIL - {validation_result['message']}")
# #             raise ValueError(f"Validation failed: {validation_result['message']}")
# 
#         # Additional custom validations
#         log("[VALIDATION] Running custom checks...")
# 
#         # Check finite estimates
#         if not np.all(np.isfinite(fe_df['estimate'])):
#             log("[VALIDATION] FAIL - Non-finite estimates found")
#             raise ValueError("Non-finite estimates in fixed effects")
#         else:
#             log("[VALIDATION] PASS - All estimates finite")
# 
#         # Check positive standard errors
#         if not np.all(fe_df['se'] > 0):
#             log("[VALIDATION] FAIL - Non-positive standard errors found")
#             raise ValueError("Non-positive standard errors in fixed effects")
#         else:
#             log("[VALIDATION] PASS - All standard errors positive")
# 
#         # Check p-values in [0, 1]
#         if not np.all((fe_df['p_uncorrected'] >= 0) & (fe_df['p_uncorrected'] <= 1)):
#             log("[VALIDATION] FAIL - p_uncorrected values outside [0, 1]")
#             raise ValueError("Invalid p-values (outside [0, 1])")
#         else:
#             log("[VALIDATION] PASS - All p-values in [0, 1] range")
# 
#         # Check Decision D068 compliance (dual p-values)
#         required_cols = ['p_uncorrected', 'p_bonferroni']
#         if not all(col in test_df.columns for col in required_cols):
#             log(f"[VALIDATION] FAIL - Missing Decision D068 columns: {required_cols}")
#             raise ValueError("Decision D068 compliance failed: missing dual p-values")
#         else:
#             log("[VALIDATION] PASS - Decision D068 dual p-values present")
# 
#         # Check quadratic term present
#         if 'TSVR_hours_squared' not in test_df['term'].values:
#             log("[VALIDATION] FAIL - Quadratic term not found in results")
#             raise ValueError("Quadratic term missing from fixed effects")
#         else:
#             log("[VALIDATION] PASS - Quadratic term present in results")
# 
#         log("[SUCCESS] Step 02 complete")
#         sys.exit(0)
# 
#     except Exception as e:
#         log(f"[ERROR] {str(e)}")
#         log("[TRACEBACK] Full error details:")
#         with open(LOG_FILE, 'a', encoding='utf-8') as f:
#             traceback.print_exc(file=f)
#         traceback.print_exc()
#         sys.exit(1)
