#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step00
Step Name: Extract Theta Scores from RQ 5.4.1
RQ: 5.4.2
Generated: 2025-11-25

PURPOSE:
Extract IRT theta scores by congruence from RQ 5.5 (DERIVED data dependency).
This step validates that RQ 5.5 completed successfully and caches its theta
outputs for use in RQ 5.6 piecewise LMM analysis.

EXPECTED INPUTS:
  - results/ch5/5.4.1/status.yaml
    Fields: rq_results.status (must be 'success')
    Expected: RQ 5.4.1 execution status file

  - results/ch5/5.4.1/data/step03_theta_scores.csv
    Columns: ['composite_ID', 'theta_common', 'theta_congruent', 'theta_incongruent',
              'se_common', 'se_congruent', 'se_incongruent']
    Expected rows: 400 (100 participants x 4 test sessions)

EXPECTED OUTPUTS:
  - data/step00_theta_scores_from_rq5.csv
    Columns: ['composite_ID', 'theta_common', 'theta_congruent', 'theta_incongruent',
              'se_common', 'se_congruent', 'se_incongruent']
    Expected rows: 400
    Description: Cached theta scores from RQ 5.5 (identical copy)

VALIDATION CRITERIA:
  - RQ 5.5 dependency satisfied: status.yaml exists AND rq_results.status = 'success'
  - Theta file exists: step03_theta_scores.csv exists
  - Row count correct: 400 rows (100 participants x 4 tests)
  - Column count correct: 7 columns (composite_ID + 3 theta + 3 SE)
  - Theta range valid: All theta_* values in [-3, 3]
  - SE range valid: All se_* values in [0.1, 1.0]
  - No missing data: No NaN in theta or SE columns

g_code REASONING:
- Approach: Dependency check + file copy with validation
- Why this approach: Ensures RQ 5.6 has stable input even if RQ 5.5 regenerated later
- Data flow: RQ 5.5 theta scores -> validation -> local cache
- Expected performance: ~1 second (simple file operations)

IMPLEMENTATION NOTES:
- Analysis: stdlib operations (dependency check + file copy)
- Validation: Inline validation (7 criteria checks)
- Critical: Must verify RQ 5.5 completed before proceeding
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import yaml
import traceback

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/ch5/5.4.2
RQ5_DIR = PROJECT_ROOT / "results" / "ch5" / "5.4.1"
LOG_FILE = RQ_DIR / "logs" / "step00_extract_theta_from_rq5.log"

# =============================================================================
# FOLDER CONVENTIONS (MANDATORY - NO EXCEPTIONS)
# =============================================================================
#
# code/   : ONLY .py scripts (generated by g_code)
# data/   : ALL data outputs (.csv, .pkl, .txt) - ANY file produced by code
# logs/   : ONLY .log files - execution logs
# plots/  : ONLY image files (.png, .pdf, .svg) - actual plot images
# results/: ONLY final summary reports (.md, .html)
# docs/   : RQ documentation (concept, plan, analysis specs)
#
# NAMING CONVENTION (MANDATORY):
# ALL files in data/ and logs/ MUST be prefixed with step number:
#   - stepXX_descriptive_name.csv
#   - stepXX_descriptive_name.pkl
#   - stepXX_descriptive_name.log

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 0: Extract Theta Scores from RQ 5.5")

        # =========================================================================
        # STEP 1: Check RQ 5.5 Dependency
        # =========================================================================
        # Expected: RQ 5.5 completed successfully (rq_results.status = 'success')
        # Purpose: Prevent proceeding if dependency not satisfied

        log("[DEPENDENCY CHECK] Validating RQ 5.5 completion status...")

        # Check status.yaml exists
        rq5_status_path = RQ5_DIR / "status.yaml"
        if not rq5_status_path.exists():
            raise FileNotFoundError(
                f"EXPECTATIONS ERROR: To extract theta from RQ 5.4.1 I expect "
                f"results/ch5/5.4.1/status.yaml, but file missing"
            )

        # Read status.yaml
        with open(rq5_status_path, 'r', encoding='utf-8') as f:
            rq5_status = yaml.safe_load(f)

        # Check rq_results.status = 'success'
        if 'rq_results' not in rq5_status:
            raise ValueError(
                f"EXPECTATIONS ERROR: RQ 5.5 status.yaml missing 'rq_results' section"
            )

        if rq5_status['rq_results'].get('status') != 'success':
            actual_status = rq5_status['rq_results'].get('status', 'UNKNOWN')
            raise ValueError(
                f"EXPECTATIONS ERROR: To extract theta from RQ 5.5 I expect "
                f"rq_results.status = 'success', but found '{actual_status}'. "
                f"RQ 5.5 must complete successfully before RQ 5.6 can proceed."
            )

        log(f"[PASS] RQ 5.5 dependency satisfied (status = success)")

        # =========================================================================
        # STEP 2: Load RQ 5.5 Theta Scores
        # =========================================================================
        # Expected: 400 rows x 7 columns (composite_ID + 3 theta + 3 SE)
        # Purpose: Cache theta scores for RQ 5.6 analysis

        log("[LOAD] Loading RQ 5.5 theta scores...")

        rq5_theta_path = RQ5_DIR / "data" / "step03_theta_scores.csv"
        if not rq5_theta_path.exists():
            raise FileNotFoundError(
                f"EXPECTATIONS ERROR: To extract theta from RQ 5.4.1 I expect "
                f"results/ch5/5.4.1/data/step03_theta_scores.csv, but file missing"
            )

        df_theta = pd.read_csv(rq5_theta_path, encoding='utf-8')
        log(f"[LOADED] {rq5_theta_path.name} ({len(df_theta)} rows, {len(df_theta.columns)} cols)")

        # =========================================================================
        # STEP 3: Validate Structure
        # =========================================================================
        # Expected: Correct columns, row count, value ranges
        # Purpose: Ensure data quality before caching

        log("[VALIDATION] Validating theta scores structure...")

        expected_columns = [
            'composite_ID',
            'theta_common', 'theta_congruent', 'theta_incongruent',
            'se_common', 'se_congruent', 'se_incongruent'
        ]

        # Check column count
        if len(df_theta.columns) != 7:
            raise ValueError(
                f"Column count incorrect: expected 7 columns, found {len(df_theta.columns)}"
            )
        log(f"[PASS] Column count correct (7 columns)")

        # Check column names
        if list(df_theta.columns) != expected_columns:
            raise ValueError(
                f"Column names incorrect: expected {expected_columns}, "
                f"found {list(df_theta.columns)}"
            )
        log(f"[PASS] Column names correct")

        # Check row count
        if len(df_theta) != 400:
            raise ValueError(
                f"Row count incorrect: expected 400 rows (100 participants x 4 tests), "
                f"found {len(df_theta)}"
            )
        log(f"[PASS] Row count correct (400 rows)")

        # Check theta value ranges
        theta_cols = ['theta_common', 'theta_congruent', 'theta_incongruent']
        for col in theta_cols:
            if df_theta[col].min() < -3.0 or df_theta[col].max() > 3.0:
                raise ValueError(
                    f"Theta range invalid for {col}: "
                    f"min={df_theta[col].min():.3f}, max={df_theta[col].max():.3f}, "
                    f"expected [-3, 3]"
                )
        log(f"[PASS] Theta value ranges valid (all in [-3, 3])")

        # Check SE value ranges
        se_cols = ['se_common', 'se_congruent', 'se_incongruent']
        for col in se_cols:
            if df_theta[col].min() < 0.1 or df_theta[col].max() > 1.0:
                raise ValueError(
                    f"SE range invalid for {col}: "
                    f"min={df_theta[col].min():.3f}, max={df_theta[col].max():.3f}, "
                    f"expected [0.1, 1.0]"
                )
        log(f"[PASS] SE value ranges valid (all in [0.1, 1.0])")

        # Check for missing data
        if df_theta[theta_cols + se_cols].isna().any().any():
            n_missing = df_theta[theta_cols + se_cols].isna().sum().sum()
            raise ValueError(
                f"Missing data detected: {n_missing} NaN values in theta/SE columns"
            )
        log(f"[PASS] No missing data (all theta and SE columns complete)")

        # =========================================================================
        # STEP 4: Save Cached Copy
        # =========================================================================
        # Output: data/step00_theta_scores_from_rq5.csv
        # Purpose: Local cache for RQ 5.6 (stable input even if RQ 5.5 regenerated)

        log("[SAVE] Saving cached theta scores...")

        output_path = RQ_DIR / "data" / "step00_theta_scores_from_rq5.csv"
        df_theta.to_csv(output_path, index=False, encoding='utf-8')

        log(f"[SAVED] {output_path.name} ({len(df_theta)} rows, {len(df_theta.columns)} cols)")

        # =========================================================================
        # STEP 5: Summary Report
        # =========================================================================

        log("[VALIDATION] All checks passed:")
        log(f"  - RQ 5.5 dependency satisfied")
        log(f"  - Theta file exists and loaded")
        log(f"  - Row count correct (400)")
        log(f"  - Column count correct (7)")
        log(f"  - Theta ranges valid ([-3, 3])")
        log(f"  - SE ranges valid ([0.1, 1.0])")
        log(f"  - No missing data")

        log("[SUCCESS] Step 0 complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
