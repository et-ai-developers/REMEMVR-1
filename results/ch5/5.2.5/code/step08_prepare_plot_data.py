#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step08
Step Name: Prepare Plot Data (Methodological Comparison Visualization)
RQ: ch5/5.2.5
Generated: 2025-11-30

PURPOSE:
Create plot source CSVs for methodological comparison visualizations:
- Plot 1: Correlation comparison (Full CTT vs Purified CTT correlations with IRT)
- Plot 2: AIC comparison (Full CTT vs Purified CTT vs IRT theta)

This step transforms analysis results into rq_plots-ready format by reshaping
correlation data to long format and annotating AIC data with significance markers.

**CRITICAL: When domain EXCLUDED** - Due to floor effect discovered in RQ 5.2.1
(77% item attrition, 6-9% floor). Only What and Where domains in plot data.

EXPECTED INPUTS:
  - data/step05_correlation_analysis.csv
    Columns: ['domain', 'r_full_irt', 'r_purified_irt', 'delta_r', 'p_bonferroni']
    Format: Steiger's z-test results comparing Full CTT-IRT vs Purified CTT-IRT correlations
    Expected rows: ~2 (what, where - no when)

  - data/step07_lmm_model_comparison.csv
    Columns: ['measurement', 'AIC', 'delta_AIC', 'interpretation']
    Format: AIC comparison of 3 parallel LMMs (Full CTT, Purified CTT, IRT theta)
    Expected rows: ~3 (one per measurement approach)

EXPECTED OUTPUTS:
  - plots/step08_correlation_comparison_data.csv
    Columns: ['domain', 'measurement_type', 'correlation', 'significance']
    Format: Long-format correlation data for grouped bar chart
    Expected rows: ~4 (2 domains x 2 measurement types)

  - plots/step08_aic_comparison_data.csv
    Columns: ['measurement', 'AIC', 'delta_AIC', 'interpretation']
    Format: AIC comparison with Burnham & Anderson interpretation
    Expected rows: ~3 (Full CTT, Purified CTT, IRT theta)

VALIDATION CRITERIA:
  - Plot 1: All domains present (what, where - no when)
  - Plot 1: All measurements present (Full CTT, Purified CTT)
  - Plot 1: Exactly 4 rows (2 domains x 2 types)
  - Plot 2: All measurements present (Full CTT, Purified CTT, IRT theta)
  - Plot 2: Exactly 3 rows
  - No NaN values in either plot data

g_code REASONING:
- Approach: Transform analysis results to plot-ready CSVs using pandas reshaping
- Why this approach: Separates data preparation from visualization (rq_plots agent
  generates actual PNG files from these CSVs)
- Data flow: Step 5 correlations + Step 7 AIC -> long-format plot source CSVs
- Expected performance: ~seconds (simple reshaping, no computation)

IMPLEMENTATION NOTES:
- Analysis type: stdlib (pandas operations, NOT catalogued tool)
- Validation tool: tools.validation.validate_plot_data_completeness
- Plot 1: Reshape correlations to long format (domain x measurement_type)
- Plot 2: Use AIC comparison directly (already plot-ready, just copy to plots/)
- Significance annotation: p_bonferroni < 0.05 for correlation improvement
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
# CRITICAL: RQ scripts are in results/chX/rqY/code/ (4 levels deep from project root)
# Path hierarchy from script location:
#   parents[0] = code/ (immediate parent)
#   parents[1] = rqY/
#   parents[2] = chX/
#   parents[3] = results/
#   parents[4] = REMEMVR/ (project root - THIS is what we need for imports)
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import validation tool
from tools.validation import validate_plot_data_completeness

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/ch5/5.2.5 (derived from script location)
LOG_FILE = RQ_DIR / "logs" / "step08_prepare_plot_data.log"

# =============================================================================
# FOLDER CONVENTIONS (MANDATORY - NO EXCEPTIONS)
# =============================================================================
#
# code/   : ONLY .py scripts (generated by g_code)
# data/   : ALL data outputs (.csv, .pkl, .txt) - ANY file produced by code
# logs/   : ONLY .log files - execution logs
# plots/  : ONLY image files (.png, .pdf, .svg) - actual plot images
#           PLUS plot source CSVs (step##_*_data.csv for rq_plots agent)
# results/: ONLY final summary reports (.md, .html)
# docs/   : RQ documentation (concept, plan, analysis specs)
#
# NAMING CONVENTION (MANDATORY):
# ALL files in data/ and logs/ MUST be prefixed with step number:
#   - stepXX_descriptive_name.csv
#   - stepXX_descriptive_name.pkl
#   - stepXX_descriptive_name.log
#
# Plot source CSVs (in plots/) also use step prefix:
#   - stepXX_plot_name_data.csv (source data for rq_plots agent)
#
# Examples:
#   CORRECT: plots/step08_correlation_comparison_data.csv
#   CORRECT: plots/step08_aic_comparison_data.csv
#   WRONG:   data/correlation_comparison_data.csv (plot CSVs go to plots/)
#   WRONG:   plots/correlation_data.csv (missing step prefix)

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 8: Prepare Plot Data (Methodological Comparison Visualization)")

        # =========================================================================
        # STEP 1: Load Input Data
        # =========================================================================
        # Expected: Correlation analysis results (Step 5) + LMM comparison (Step 7)
        # Purpose: Transform analysis results to rq_plots-ready format

        log("[LOAD] Loading input data...")

        # Load Step 5 correlation analysis results
        # Contains: domain, r_full_irt, r_purified_irt, delta_r, p_bonferroni, etc.
        df_corr = pd.read_csv(RQ_DIR / "data/step05_correlation_analysis.csv")
        log(f"[LOADED] step05_correlation_analysis.csv ({len(df_corr)} rows, {len(df_corr.columns)} cols)")
        log(f"  Columns: {df_corr.columns.tolist()}")

        # Load Step 7 LMM model comparison
        # Contains: measurement, AIC, delta_AIC, interpretation
        df_aic = pd.read_csv(RQ_DIR / "data/step07_lmm_model_comparison.csv")
        log(f"[LOADED] step07_lmm_model_comparison.csv ({len(df_aic)} rows, {len(df_aic.columns)} cols)")
        log(f"  Columns: {df_aic.columns.tolist()}")

        # =========================================================================
        # STEP 2: Prepare Plot 1 Data (Correlation Comparison)
        # =========================================================================
        # Tool: Pandas reshaping (long format for grouped bar chart)
        # What it does: Reshape correlation data to domain x measurement_type
        # Expected output: 6 rows (3 domains x 2 measurement types)

        log("[PLOT1] Preparing correlation comparison data...")

        # Reshape correlations to long format
        # Original: domain | r_full_irt | r_purified_irt | ...
        # Target:   domain | measurement_type | correlation | significance

        plot1_data = []

        for _, row in df_corr.iterrows():
            domain = row['domain']

            # Full CTT row
            plot1_data.append({
                'domain': domain,
                'measurement_type': 'Full CTT',
                'correlation': row['r_full_irt'],
                'significance': 'Not significant' if row['p_bonferroni'] >= 0.05 else 'Significant improvement'
            })

            # Purified CTT row
            plot1_data.append({
                'domain': domain,
                'measurement_type': 'Purified CTT',
                'correlation': row['r_purified_irt'],
                'significance': 'Not significant' if row['p_bonferroni'] >= 0.05 else 'Significant improvement'
            })

        df_plot1 = pd.DataFrame(plot1_data)

        log(f"[PLOT1] Created correlation comparison data ({len(df_plot1)} rows)")
        log(f"  Domains: {sorted(df_plot1['domain'].unique())}")
        log(f"  Measurement types: {sorted(df_plot1['measurement_type'].unique())}")

        # =========================================================================
        # STEP 3: Prepare Plot 2 Data (AIC Comparison)
        # =========================================================================
        # Tool: Direct copy (AIC comparison already plot-ready)
        # What it does: Copy AIC comparison to plots/ folder for rq_plots agent
        # Expected output: 3 rows (Full CTT, Purified CTT, IRT theta)

        log("[PLOT2] Preparing AIC comparison data...")

        # AIC comparison is already plot-ready (measurement, AIC, delta_AIC, interpretation)
        # Just select relevant columns and copy to plots/
        df_plot2 = df_aic[['measurement', 'AIC', 'delta_AIC', 'interpretation']].copy()

        log(f"[PLOT2] Created AIC comparison data ({len(df_plot2)} rows)")
        log(f"  Measurements: {sorted(df_plot2['measurement'].unique())}")
        log(f"  AIC range: [{df_plot2['AIC'].min():.2f}, {df_plot2['AIC'].max():.2f}]")
        log(f"  Delta AIC range: [{df_plot2['delta_AIC'].min():.2f}, {df_plot2['delta_AIC'].max():.2f}]")

        # =========================================================================
        # STEP 4: Save Plot Data CSVs
        # =========================================================================
        # These outputs will be used by: rq_plots agent to generate PNG visualizations

        log("[SAVE] Saving plot data CSVs...")

        # Save Plot 1 data (correlation comparison)
        # Output: plots/step08_correlation_comparison_data.csv
        # Contains: Grouped bar chart data (Full CTT vs Purified CTT correlations with IRT)
        plot1_path = RQ_DIR / "plots/step08_correlation_comparison_data.csv"
        df_plot1.to_csv(plot1_path, index=False, encoding='utf-8')
        log(f"[SAVED] step08_correlation_comparison_data.csv ({len(df_plot1)} rows, {len(df_plot1.columns)} cols)")

        # Save Plot 2 data (AIC comparison)
        # Output: plots/step08_aic_comparison_data.csv
        # Contains: Bar chart data (Full CTT vs Purified CTT vs IRT theta AIC values)
        plot2_path = RQ_DIR / "plots/step08_aic_comparison_data.csv"
        df_plot2.to_csv(plot2_path, index=False, encoding='utf-8')
        log(f"[SAVED] step08_aic_comparison_data.csv ({len(df_plot2)} rows, {len(df_plot2.columns)} cols)")

        # =========================================================================
        # STEP 5: Run Validation Tool
        # =========================================================================
        # Tool: validate_plot_data_completeness
        # Validates: All domains/measurements present in plot data
        # Threshold: No missing categories (complete factorial design)

        log("[VALIDATION] Running validate_plot_data_completeness...")

        # Validate Plot 1 data
        # Expected: All domains (what, where - no when) + all measurement types (Full CTT, Purified CTT)
        validation_result1 = validate_plot_data_completeness(
            plot_data=df_plot1,
            required_domains=['what', 'where'],  # When excluded
            required_groups=['Full CTT', 'Purified CTT'],
            domain_col='domain',
            group_col='measurement_type'
        )

        # Report validation results for Plot 1
        # Expected: All domains/measurements present, no missing data
        if isinstance(validation_result1, dict):
            log(f"[VALIDATION] Plot 1 result: {validation_result1.get('message', validation_result1)}")
            if not validation_result1.get('valid', False):
                log(f"[ERROR] Plot 1 validation failed")
                raise ValueError(f"Plot 1 validation failed: {validation_result1.get('message', 'Unknown error')}")
        else:
            log(f"[VALIDATION] Plot 1 result: {validation_result1}")

        # Validate Plot 2 data
        # Expected: All measurements (Full CTT, Purified CTT, IRT theta)
        # Note: Plot 2 doesn't have a domain dimension, so we validate measurements only
        if len(df_plot2) != 3:
            log(f"[ERROR] Plot 2 should have exactly 3 rows (Full CTT, Purified CTT, IRT theta), got {len(df_plot2)}")
            raise ValueError(f"Plot 2 validation failed: Expected 3 rows, got {len(df_plot2)}")

        expected_measurements = ['Full CTT', 'Purified CTT', 'IRT theta']
        actual_measurements = set(df_plot2['measurement'].unique())
        missing_measurements = set(expected_measurements) - actual_measurements

        if missing_measurements:
            log(f"[ERROR] Plot 2 missing measurements: {missing_measurements}")
            raise ValueError(f"Plot 2 validation failed: Missing measurements {missing_measurements}")

        log(f"[VALIDATION] Plot 2 result: All measurements present (Full CTT, Purified CTT, IRT theta)")

        # Check for NaN values in either plot data
        if df_plot1.isnull().any().any():
            log(f"[ERROR] Plot 1 contains NaN values")
            raise ValueError("Plot 1 validation failed: Contains NaN values")

        if df_plot2.isnull().any().any():
            log(f"[ERROR] Plot 2 contains NaN values")
            raise ValueError("Plot 2 validation failed: Contains NaN values")

        log(f"[VALIDATION] No NaN values detected in plot data")

        log("[SUCCESS] Step 8 complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
