#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Plotting script for RQ 5.3.8 - Paradigm-Based Clustering

GENERATED BY: rq_plots agent (v4.0.0)
DATE: 2025-12-04
PURPOSE: Create publication-ready plots from pre-aggregated plot source CSVs

PLOTS GENERATED:
1. scatter_matrix.png - 6x6 scatter plot matrix of paradigm features colored by cluster
2. elbow_plot.png - BIC elbow plot for K selection with optimal K=3 marked
"""

from pathlib import Path
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# =============================================================================
# SETUP
# =============================================================================

# Get absolute path to RQ root (plots.py is in results/ch5/5.3.8/plots/)
RQ_ROOT = Path(__file__).parent.parent

# Apply plotting style
plt.style.use('seaborn-v0_8-whitegrid')
sns.set_palette("husl")

print("Starting plotting for RQ 5.3.8...")
print(f"RQ root: {RQ_ROOT}")

# =============================================================================
# PLOT 1: SCATTER MATRIX (6x6 feature pairs colored by cluster)
# =============================================================================

print("\nGenerating Plot 1: Scatter matrix...")

# Load plot source CSV (created by analysis pipeline)
df_scatter = pd.read_csv(RQ_ROOT / "data" / "step07_scatter_matrix_data.csv")
print(f"  Loaded {len(df_scatter)} rows from step07_scatter_matrix_data.csv")
print(f"  Columns: {list(df_scatter.columns)}")
print(f"  Clusters: {sorted(df_scatter['cluster'].unique())}")

# Extract feature columns (exclude UID and cluster)
feature_cols = [col for col in df_scatter.columns if col.endswith('_z') and col != 'cluster']
print(f"  Features: {feature_cols}")

# Create readable feature names for plot
feature_names_map = {
    'Total_Intercept_Cued_z': 'Cued\nIntercept',
    'Total_Intercept_Free_z': 'Free\nIntercept',
    'Total_Intercept_Recognition_z': 'Recognition\nIntercept',
    'Total_Slope_Cued_z': 'Cued\nSlope',
    'Total_Slope_Free_z': 'Free\nSlope',
    'Total_Slope_Recognition_z': 'Recognition\nSlope'
}

# Reorder features for better visualization (intercepts first, then slopes)
feature_order = [
    'Total_Intercept_Free_z',
    'Total_Intercept_Cued_z',
    'Total_Intercept_Recognition_z',
    'Total_Slope_Free_z',
    'Total_Slope_Cued_z',
    'Total_Slope_Recognition_z'
]

# Create DataFrame with ordered features
df_plot = df_scatter[feature_order + ['cluster']].copy()

# Use seaborn pairplot for scatter matrix
g = sns.pairplot(
    df_plot,
    hue='cluster',
    vars=feature_order,
    diag_kind='kde',
    plot_kws={'alpha': 0.6, 's': 30},
    diag_kws={'alpha': 0.7},
    palette='Set2',
    height=2.0,
    aspect=1.0
)

# Update axis labels with readable names
for i, col in enumerate(feature_order):
    for j in range(len(feature_order)):
        if i == len(feature_order) - 1:  # Bottom row
            g.axes[i, j].set_xlabel(feature_names_map[col], fontsize=8)
        if j == 0:  # Left column
            g.axes[i, j].set_ylabel(feature_names_map[feature_order[i]], fontsize=8)

# Adjust title and legend
g.fig.suptitle('RQ 5.3.8: Paradigm Feature Scatter Matrix by Cluster',
               fontsize=14, y=1.00)
g._legend.set_title('Cluster')
g._legend.set_bbox_to_anchor((1.05, 0.5))

# Save figure
output_path = RQ_ROOT / "plots" / "scatter_matrix.png"
g.fig.savefig(output_path, dpi=300, bbox_inches='tight')
plt.close(g.fig)

print(f"  -> Saved: plots/scatter_matrix.png")

# =============================================================================
# PLOT 2: ELBOW PLOT (BIC vs K with optimal K=3 marked)
# =============================================================================

print("\nGenerating Plot 2: BIC elbow plot...")

# Load elbow plot data
df_elbow = pd.read_csv(RQ_ROOT / "data" / "step02_elbow_plot_data.csv")
print(f"  Loaded {len(df_elbow)} rows from step02_elbow_plot_data.csv")
print(f"  K range: {df_elbow['K'].min()} to {df_elbow['K'].max()}")

# Optimal K (from parsimony rule)
optimal_k = 3

# Create figure with single plot
fig, ax = plt.subplots(figsize=(8, 6))

# Plot BIC vs K
ax.plot(df_elbow['K'], df_elbow['BIC'],
        marker='o', linewidth=2, markersize=8,
        color='#2E86AB', label='BIC')

# Mark optimal K with star
optimal_bic = df_elbow.loc[df_elbow['K'] == optimal_k, 'BIC'].values[0]
ax.plot(optimal_k, optimal_bic,
        marker='*', markersize=20, color='#A23B72',
        label=f'Optimal K={optimal_k}', zorder=5)

# Add vertical line at optimal K
ax.axvline(x=optimal_k, color='#A23B72', linestyle='--',
           alpha=0.5, linewidth=1.5)

# Labels and styling
ax.set_xlabel('Number of Clusters (K)', fontsize=12)
ax.set_ylabel('BIC (Bayesian Information Criterion)', fontsize=12)
ax.set_title('RQ 5.3.8: Cluster Selection via BIC\n(Parsimony Rule: K=3 selected)',
             fontsize=14)
ax.legend(fontsize=10, loc='upper right')
ax.grid(True, alpha=0.3)

# Set x-axis to show only integer K values
ax.set_xticks(df_elbow['K'])

# Save figure
output_path = RQ_ROOT / "plots" / "elbow_plot.png"
fig.savefig(output_path, dpi=300, bbox_inches='tight')
plt.close(fig)

print(f"  -> Saved: plots/elbow_plot.png")

# =============================================================================
# SUMMARY
# =============================================================================

print("\n" + "="*70)
print("PLOTTING COMPLETE")
print("="*70)
print(f"Total plots generated: 2")
print(f"  - plots/scatter_matrix.png (6x6 feature scatter matrix)")
print(f"  - plots/elbow_plot.png (BIC elbow with K=3 marked)")
print("\nAll plots saved with 300 DPI publication quality.")
print("="*70)
