#!/usr/bin/env python3
"""
Extended Model Comparison for RQ 5.1.1

PURPOSE:
Test additional functional forms beyond the original 5 models:
- Original 5: Linear, Quadratic, Log, Lin+Log, Quad+Log
- Power Law variants: y ~ t^-α (via log-log transformation)
- Exponential decay: y ~ exp(-λt)
- Square root: y ~ sqrt(t)
- Reciprocal: y ~ 1/t

This script extends step05 to answer: "Does power law fit better than logarithmic?"

INPUTS:
  - data/step04_lmm_input.csv (same as step05)

OUTPUTS:
  - data/step05b_extended_model_fits.pkl
  - results/step05b_extended_model_comparison.csv
  - logs/step05b_extended_lmm_fitting.log
"""

import sys
from pathlib import Path
import pandas as pd
import numpy as np
import statsmodels.formula.api as smf
import pickle
import traceback

# Add project root to path
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import tools
from tools.analysis_lmm import fit_lmm_trajectory

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]
LOG_FILE = RQ_DIR / "logs" / "step05b_extended_lmm_fitting.log"

# =============================================================================
# Logging
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 5b: Extended Model Comparison")

        # =====================================================================
        # STEP 1: Load LMM Input Data
        # =====================================================================

        log("[LOAD] Loading LMM input data...")
        input_path = RQ_DIR / "data" / "step04_lmm_input.csv"

        if not input_path.exists():
            raise FileNotFoundError(f"LMM input data missing: {input_path}")

        lmm_input = pd.read_csv(input_path, encoding='utf-8')
        log(f"[LOADED] {len(lmm_input)} rows, {len(lmm_input.columns)} cols")

        # Rename for compatibility
        lmm_input = lmm_input.rename(columns={
            'Theta': 'Ability',
            'Days_squared': 'Days_sq',
            'log_Days_plus1': 'log_Days'
        })

        # =====================================================================
        # STEP 2: Add New Time Transformations
        # =====================================================================

        log("[TRANSFORM] Adding new time transformations...")

        # Power law variants (log-log transformation)
        # Power law: y = a * t^(-α) <=> log(y_shifted) ~ -α * log(t+1)
        # We'll use log_Days as predictor (already exists: log(Days+1))
        # For true power law comparison, we need log_log: log(log(Days+1)+1)
        lmm_input['log_log_Days'] = np.log(lmm_input['log_Days'] + 1)

        # Exponential decay: y = a * exp(-λt) <=> y ~ exp(-Days)
        # Can't directly model exp(-Days) in LMM, but we can use -Days as proxy
        lmm_input['neg_Days'] = -lmm_input['Days']

        # Square root: y ~ sqrt(t)
        lmm_input['sqrt_Days'] = np.sqrt(lmm_input['Days'])

        # Reciprocal: y ~ 1/(t+1) to avoid division by zero
        lmm_input['recip_Days'] = 1.0 / (lmm_input['Days'] + 1)

        # Cube root: y ~ t^(1/3)
        lmm_input['cbrt_Days'] = np.cbrt(lmm_input['Days'])

        # Power law with different exponents
        # y ~ t^(-0.5), t^(-0.3), t^(-0.7)
        lmm_input['Days_pow_neg05'] = (lmm_input['Days'] + 1) ** (-0.5)
        lmm_input['Days_pow_neg03'] = (lmm_input['Days'] + 1) ** (-0.3)
        lmm_input['Days_pow_neg07'] = (lmm_input['Days'] + 1) ** (-0.7)

        log("  Added transformations:")
        log("    - log_log_Days: log(log(Days+1)+1)")
        log("    - sqrt_Days: sqrt(Days)")
        log("    - cbrt_Days: cbrt(Days)")
        log("    - recip_Days: 1/(Days+1)")
        log("    - Days_pow_neg05: (Days+1)^(-0.5)")
        log("    - Days_pow_neg03: (Days+1)^(-0.3)")
        log("    - Days_pow_neg07: (Days+1)^(-0.7)")
        log("    - neg_Days: -Days (exponential proxy)")

        # =====================================================================
        # STEP 3: Define Extended Model Set
        # =====================================================================

        log("[CONFIG] Defining extended model set...")

        # Original 5 models (for comparison)
        models = {
            # ---- ORIGINAL 5 MODELS ----
            'Linear': 'Ability ~ Days',
            'Quadratic': 'Ability ~ Days + Days_sq',
            'Log': 'Ability ~ log_Days',
            'Lin+Log': 'Ability ~ Days + log_Days',
            'Quad+Log': 'Ability ~ Days + Days_sq + log_Days',

            # ---- POWER LAW VARIANTS ----
            'PowerLaw_LogLog': 'Ability ~ log_log_Days',
            'PowerLaw_Alpha05': 'Ability ~ Days_pow_neg05',
            'PowerLaw_Alpha03': 'Ability ~ Days_pow_neg03',
            'PowerLaw_Alpha07': 'Ability ~ Days_pow_neg07',
            'PowerLaw_Combined': 'Ability ~ log_Days + log_log_Days',

            # ---- ROOT MODELS ----
            'SquareRoot': 'Ability ~ sqrt_Days',
            'CubeRoot': 'Ability ~ cbrt_Days',
            'SquareRoot+Log': 'Ability ~ sqrt_Days + log_Days',

            # ---- RECIPROCAL MODELS ----
            'Reciprocal': 'Ability ~ recip_Days',
            'Recip+Log': 'Ability ~ recip_Days + log_Days',

            # ---- EXPONENTIAL PROXY ----
            'Exponential': 'Ability ~ neg_Days',
            'Exp+Log': 'Ability ~ neg_Days + log_Days',
        }

        log(f"  Total models to fit: {len(models)}")

        # =====================================================================
        # STEP 4: Fit All Models
        # =====================================================================

        log("[ANALYSIS] Fitting all models...")

        fitted_models = {}
        model_stats = []

        save_dir = RQ_DIR / "data"
        save_dir.mkdir(parents=True, exist_ok=True)

        for model_name, formula in models.items():
            log(f"  Fitting {model_name}...")

            try:
                # Fit model with random intercepts only (for simplicity)
                result = fit_lmm_trajectory(
                    data=lmm_input,
                    formula=formula,
                    groups='UID',
                    re_formula='~1',  # Random intercept only
                    reml=False
                )

                fitted_models[model_name] = result

                model_stats.append({
                    'model_name': model_name,
                    'AIC': result.aic,
                    'BIC': result.bic,
                    'log_likelihood': result.llf,
                    'n_params': result.params.shape[0],
                    'converged': result.converged
                })

                log(f"    ✓ AIC={result.aic:.2f}")

            except Exception as e:
                log(f"    ✗ FAILED: {str(e)}")
                fitted_models[model_name] = None
                model_stats.append({
                    'model_name': model_name,
                    'AIC': np.inf,
                    'BIC': np.inf,
                    'log_likelihood': -np.inf,
                    'n_params': np.nan,
                    'converged': False
                })

        # =====================================================================
        # STEP 5: Compute AIC Comparison Metrics
        # =====================================================================

        log("[COMPUTE] Computing AIC comparison metrics...")

        comparison_df = pd.DataFrame(model_stats)

        # Remove failed models
        comparison_df = comparison_df[comparison_df['AIC'] != np.inf].copy()

        # Sort by AIC
        comparison_df = comparison_df.sort_values('AIC').reset_index(drop=True)

        # Compute delta AIC
        aic_min = comparison_df['AIC'].min()
        comparison_df['delta_AIC'] = comparison_df['AIC'] - aic_min

        # Compute Akaike weights
        comparison_df['akaike_weight'] = np.exp(-0.5 * comparison_df['delta_AIC'])
        weight_sum = comparison_df['akaike_weight'].sum()
        comparison_df['akaike_weight'] = comparison_df['akaike_weight'] / weight_sum

        # Compute cumulative weights
        comparison_df['cumulative_weight'] = comparison_df['akaike_weight'].cumsum()

        log("[RESULTS] Extended Model Comparison:")
        log("")
        log(comparison_df[['model_name', 'AIC', 'delta_AIC', 'akaike_weight']].to_string(index=False))
        log("")

        # =====================================================================
        # STEP 6: Identify Best Model
        # =====================================================================

        best_model_name = comparison_df.iloc[0]['model_name']
        best_model_aic = comparison_df.iloc[0]['AIC']
        best_model_weight = comparison_df.iloc[0]['akaike_weight']

        log(f"[BEST MODEL] {best_model_name}")
        log(f"  AIC: {best_model_aic:.2f}")
        log(f"  Weight: {best_model_weight:.4f} ({best_model_weight*100:.1f}%)")

        # Find original Log model for comparison
        log_model_row = comparison_df[comparison_df['model_name'] == 'Log']
        if len(log_model_row) > 0:
            log_rank = log_model_row.index[0] + 1
            log_aic = log_model_row.iloc[0]['AIC']
            log_weight = log_model_row.iloc[0]['akaike_weight']
            log_delta = log_model_row.iloc[0]['delta_AIC']

            log("")
            log(f"[COMPARISON] Original 'Log' model:")
            log(f"  Rank: #{log_rank} of {len(comparison_df)}")
            log(f"  AIC: {log_aic:.2f} (Δ = {log_delta:.2f})")
            log(f"  Weight: {log_weight:.4f} ({log_weight*100:.1f}%)")

        # Check power law models
        power_law_models = comparison_df[comparison_df['model_name'].str.contains('PowerLaw')]
        if len(power_law_models) > 0:
            log("")
            log("[POWER LAW MODELS]")
            for idx, row in power_law_models.iterrows():
                rank = idx + 1
                log(f"  #{rank}: {row['model_name']}")
                log(f"       AIC={row['AIC']:.2f}, Δ={row['delta_AIC']:.2f}, weight={row['akaike_weight']:.4f}")

        # =====================================================================
        # STEP 7: Save Results
        # =====================================================================

        log("[SAVE] Saving results...")

        # Save comparison table
        comparison_output = RQ_DIR / "results" / "step05b_extended_model_comparison.csv"
        comparison_df.to_csv(comparison_output, index=False, encoding='utf-8')
        log(f"  ✓ {comparison_output.name}")

        # Save fitted models
        pickle_path = RQ_DIR / "data" / "step05b_extended_model_fits.pkl"
        with open(pickle_path, 'wb') as f:
            pickle.dump(fitted_models, f)
        log(f"  ✓ {pickle_path.name}")

        # =====================================================================
        # STEP 8: Summary Statistics
        # =====================================================================

        log("")
        log("[SUMMARY]")
        log(f"  Total models tested: {len(models)}")
        log(f"  Successful fits: {len(comparison_df)}")
        log(f"  Failed fits: {len(models) - len(comparison_df)}")
        log(f"  Best model: {best_model_name}")
        log(f"  Best AIC: {best_model_aic:.2f}")
        log(f"  Original Log model rank: #{log_rank if len(log_model_row) > 0 else 'N/A'}")

        # Check if any power law model beat Log
        if len(power_law_models) > 0:
            best_power_law_rank = power_law_models.index[0] + 1
            if best_power_law_rank < log_rank:
                log(f"  ✓ POWER LAW WINS: Best power law (#{best_power_law_rank}) beats Log (#{log_rank})")
            else:
                log(f"  ✗ LOG WINS: Log (#{log_rank}) beats best power law (#{best_power_law_rank})")

        log("[SUCCESS] Step 5b complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
