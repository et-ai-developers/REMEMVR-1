#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: 03
Step Name: step03_extract_age_effects
RQ: results/ch5/rq9
Generated: 2025-11-28

PURPOSE:
Extract age effects (baseline + 2 slopes), apply Bonferroni correction

This step extracts the three age-related fixed effects from the LMM fitted in
Step 2 and applies Bonferroni correction for multiple comparisons. The three
age effects test whether age influences: (1) baseline memory (Age_c),
(2) linear forgetting rate (Time:Age_c), and (3) logarithmic forgetting rate
(Time_log:Age_c). Bonferroni correction accounts for 3 simultaneous tests
(alpha_corrected = 0.05 / 3 = 0.0167).

EXPECTED INPUTS:
  - data/step02_fixed_effects.csv
    Columns: ['term', 'coef', 'se', 'z', 'p']
    Format: Fixed effects table from statsmodels LMM with 6 rows (Intercept + 5 predictors)
    Expected rows: ~6

EXPECTED OUTPUTS:
  - data/step03_age_effects.csv
    Columns: ['term', 'hypothesis', 'coef', 'se', 'z', 'p_uncorrected', 'p_bonferroni', 'sig_uncorrected', 'sig_bonferroni', 'interpretation']
    Format: Age effects summary with dual p-values (Decision D068 compliance)
    Expected rows: ~3

VALIDATION CRITERIA:
  - validate_contrasts_d068: Dual p-value reporting (p_uncorrected + p_bonferroni)
  - validate_hypothesis_test_dual_pvalues: Required terms present (Age_c, Time:Age_c, Time_log:Age_c) + D068 compliance

g_code REASONING:
- Approach: Filter fixed effects table to extract 3 age-related terms, apply
  Bonferroni correction (multiply p-values by 3, cap at 1.0), create significance
  flags for both uncorrected and corrected p-values, and add hypothesis labels
  and interpretations
- Why this approach: Bonferroni is conservative but appropriate for planned
  comparisons with correlated tests (3 age effects from same model). Decision D068
  requires dual reporting (uncorrected + corrected) to enable comparison with
  other studies and sensitivity analysis
- Data flow: step02_fixed_effects.csv (6 rows) -> filter to 3 age rows -> apply
  Bonferroni -> add interpretation -> step03_age_effects.csv (3 rows)
- Expected performance: ~seconds (simple table filtering and arithmetic)

IMPLEMENTATION NOTES:
- Analysis tool: stdlib (pandas filtering and arithmetic)
- Validation tools:
  - validate_contrasts_d068 from tools.validation
  - validate_hypothesis_test_dual_pvalues from tools.validation
- Parameters:
  - required_terms: ["Age_c", "Time:Age_c", "Time_log:Age_c"]
  - alpha_bonferroni: 0.0167 (0.05 / 3 tests)
  - n_tests: 3
- Key logic: Negative coefficients indicate older adults perform worse (expected
  pattern for aging effects on memory)
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
# CRITICAL: RQ scripts are in results/chX/rqY/code/ (4 levels deep from project root)
# Path hierarchy from script location:
#   parents[0] = code/ (immediate parent)
#   parents[1] = rqY/
#   parents[2] = chX/
#   parents[3] = results/
#   parents[4] = REMEMVR/ (project root - THIS is what we need for imports)
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import validation tools
from tools.validation import validate_contrasts_d068, validate_hypothesis_test_dual_pvalues

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/chX/rqY (derived from script location)
LOG_FILE = RQ_DIR / "logs" / "step03_extract_age_effects.log"

# =============================================================================
# FOLDER CONVENTIONS (MANDATORY - NO EXCEPTIONS)
# =============================================================================
#
# code/   : ONLY .py scripts (generated by g_code)
# data/   : ALL data outputs (.csv, .pkl, .txt) - ANY file produced by code
# logs/   : ONLY .log files - execution logs
# plots/  : ONLY image files (.png, .pdf, .svg) - actual plot images
# results/: ONLY final summary reports (.md, .html)
# docs/   : RQ documentation (concept, plan, analysis specs)
#
# NAMING CONVENTION (MANDATORY):
# ALL files in data/ and logs/ MUST be prefixed with step number:
#   - stepXX_descriptive_name.csv
#   - stepXX_descriptive_name.pkl
#   - stepXX_descriptive_name.log
#
# Examples:
#   CORRECT: data/step05_lmm_model_comparison.csv
#   CORRECT: data/step03_theta_scores.csv
#   WRONG:   results/lmm_model_comparison.csv  (wrong folder + no prefix)
#   WRONG:   data/theta_scores.csv             (missing step prefix)
#   WRONG:   logs/step02_removed_items.csv     (CSV in logs folder)

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 03: Extract Age Effects with Bonferroni Correction")

        # =========================================================================
        # STEP 1: Load Fixed Effects Table from Step 2
        # =========================================================================
        # Expected: 6 rows (Intercept + Time + Time_log + Age_c + Time:Age_c + Time_log:Age_c)
        # Purpose: Extract the 3 age-related terms for hypothesis testing

        log("[LOAD] Loading fixed effects from Step 2...")
        input_path = RQ_DIR / "data" / "step02_fixed_effects.csv"
        fixed_effects = pd.read_csv(input_path, encoding='utf-8')
        log(f"[LOADED] step02_fixed_effects.csv ({len(fixed_effects)} rows, {len(fixed_effects.columns)} cols)")
        log(f"[INFO] Fixed effect terms: {fixed_effects['term'].tolist()}")

        # =========================================================================
        # STEP 2: Extract Age-Related Terms
        # =========================================================================
        # Tool: pandas filtering
        # What it does: Filter to 3 age effects (Age_c, Time:Age_c, Time_log:Age_c)
        # Expected output: 3 rows with age-related coefficients

        log("[ANALYSIS] Extracting age-related terms...")

        # Define required age effect terms
        required_terms = ["Age_c", "Time:Age_c", "Time_log:Age_c"]

        # Filter to age effects
        age_effects = fixed_effects[fixed_effects['term'].isin(required_terms)].copy()

        # Check we got all 3 terms
        if len(age_effects) != 3:
            missing = set(required_terms) - set(age_effects['term'].tolist())
            raise ValueError(f"Missing age effect terms: {missing}. Found only {age_effects['term'].tolist()}")

        log(f"[EXTRACTED] {len(age_effects)} age effect terms")

        # Rename p-value column to p_uncorrected (Decision D068 requirement)
        age_effects = age_effects.rename(columns={'p': 'p_uncorrected'})

        # =========================================================================
        # STEP 3: Apply Bonferroni Correction
        # =========================================================================
        # Tool: pandas arithmetic
        # What it does: Multiply uncorrected p-values by 3 (number of tests), cap at 1.0
        # Expected output: p_bonferroni column with corrected p-values

        log("[ANALYSIS] Applying Bonferroni correction (n_tests=3, alpha_corrected=0.0167)...")

        n_tests = 3
        alpha_uncorrected = 0.05
        alpha_bonferroni = alpha_uncorrected / n_tests  # 0.0167

        # Apply Bonferroni correction: p_bonf = min(p_uncorr * n_tests, 1.0)
        age_effects['p_bonferroni'] = age_effects['p_uncorrected'] * n_tests
        age_effects['p_bonferroni'] = age_effects['p_bonferroni'].clip(upper=1.0)

        log(f"[DONE] Bonferroni correction applied (alpha_corrected = {alpha_bonferroni:.4f})")

        # =========================================================================
        # STEP 4: Create Significance Flags
        # =========================================================================
        # Tool: pandas boolean operations
        # What it does: Flag effects as significant at uncorrected and corrected thresholds
        # Expected output: sig_uncorrected and sig_bonferroni boolean columns

        log("[ANALYSIS] Creating significance flags...")

        age_effects['sig_uncorrected'] = age_effects['p_uncorrected'] < alpha_uncorrected
        age_effects['sig_bonferroni'] = age_effects['p_bonferroni'] < alpha_uncorrected

        log(f"[INFO] Significant (uncorrected): {age_effects['sig_uncorrected'].sum()}/3")
        log(f"[INFO] Significant (Bonferroni): {age_effects['sig_bonferroni'].sum()}/3")

        # =========================================================================
        # STEP 5: Add Hypothesis Labels and Interpretations
        # =========================================================================
        # Tool: pandas mapping
        # What it does: Add human-readable hypothesis descriptions and coefficient interpretations
        # Expected output: hypothesis and interpretation columns

        log("[ANALYSIS] Adding hypothesis labels and interpretations...")

        # Define hypothesis labels
        hypothesis_map = {
            'Age_c': 'H1: Age affects baseline memory (intercept)',
            'Time:Age_c': 'H2: Age affects linear forgetting rate',
            'Time_log:Age_c': 'H3: Age affects logarithmic forgetting rate'
        }

        age_effects['hypothesis'] = age_effects['term'].map(hypothesis_map)

        # Interpretation: Negative coefficients = older adults worse (expected)
        def interpret_age_effect(row):
            """Generate interpretation based on coefficient direction and significance."""
            term = row['term']
            coef = row['coef']
            sig = row['sig_bonferroni']

            direction = "negative (older adults worse)" if coef < 0 else "positive (older adults better)"
            sig_text = "significant" if sig else "not significant"

            if term == 'Age_c':
                return f"Baseline memory: {direction}, {sig_text} (Bonferroni)"
            elif term == 'Time:Age_c':
                return f"Linear forgetting rate: {direction}, {sig_text} (Bonferroni)"
            elif term == 'Time_log:Age_c':
                return f"Logarithmic forgetting rate: {direction}, {sig_text} (Bonferroni)"
            else:
                return f"{direction}, {sig_text} (Bonferroni)"

        age_effects['interpretation'] = age_effects.apply(interpret_age_effect, axis=1)

        log("[DONE] Hypothesis labels and interpretations added")

        # =========================================================================
        # STEP 6: Save Age Effects Table
        # =========================================================================
        # These outputs will be used by: Step 4 (effect size computation), rq_results (interpretation)

        log("[SAVE] Saving age effects table...")
        output_path = RQ_DIR / "data" / "step03_age_effects.csv"

        # Reorder columns for clarity (Decision D068 requires dual p-values)
        column_order = [
            'term', 'hypothesis', 'coef', 'se', 'z',
            'p_uncorrected', 'p_bonferroni',
            'sig_uncorrected', 'sig_bonferroni',
            'interpretation'
        ]
        age_effects = age_effects[column_order]

        age_effects.to_csv(output_path, index=False, encoding='utf-8')
        log(f"[SAVED] step03_age_effects.csv ({len(age_effects)} rows, {len(age_effects.columns)} cols)")

        # Log summary statistics
        for _, row in age_effects.iterrows():
            log(f"[RESULT] {row['term']}: coef={row['coef']:.4f}, p_uncorr={row['p_uncorrected']:.4f}, p_bonf={row['p_bonferroni']:.4f}")

        # =========================================================================
        # STEP 7: Run Validation Tool 1 - D068 Compliance Check
        # =========================================================================
        # Tool: validate_contrasts_d068
        # Validates: Dual p-value reporting (p_uncorrected + p_bonferroni present)
        # Threshold: Must have BOTH columns for Decision D068 compliance

        log("[VALIDATION] Running validate_contrasts_d068...")
        validation_result_1 = validate_contrasts_d068(contrasts_df=age_effects)

        # Report validation results
        if isinstance(validation_result_1, dict):
            log(f"[VALIDATION] D068 compliance: {validation_result_1.get('d068_compliant', False)}")
            log(f"[VALIDATION] Valid: {validation_result_1.get('valid', False)}")
            log(f"[VALIDATION] Message: {validation_result_1.get('message', 'N/A')}")

            if not validation_result_1.get('valid', False):
                raise ValueError(f"D068 compliance validation failed: {validation_result_1.get('message', 'Unknown error')}")
        else:
            log(f"[VALIDATION] Result: {validation_result_1}")

        # =========================================================================
        # STEP 8: Run Validation Tool 2 - Required Terms Check
        # =========================================================================
        # Tool: validate_hypothesis_test_dual_pvalues
        # Validates: All 3 age effect terms present AND D068 compliance
        # Threshold: Must have all required terms with dual p-values

        log("[VALIDATION] Running validate_hypothesis_test_dual_pvalues...")
        validation_result_2 = validate_hypothesis_test_dual_pvalues(
            interaction_df=age_effects.set_index('term'),  # Function expects term as index
            required_terms=required_terms,
            alpha_bonferroni=alpha_bonferroni
        )

        # Report validation results
        if isinstance(validation_result_2, dict):
            log(f"[VALIDATION] All required terms present: {validation_result_2.get('valid', False)}")
            log(f"[VALIDATION] D068 compliance: {validation_result_2.get('d068_compliant', False)}")
            log(f"[VALIDATION] Message: {validation_result_2.get('message', 'N/A')}")

            if validation_result_2.get('missing_terms'):
                log(f"[VALIDATION] Missing terms: {validation_result_2['missing_terms']}")

            if not validation_result_2.get('valid', False):
                log(f"[VALIDATION] WARNING: {validation_result_2.get('message', 'Unknown error')}")
                log("[INFO] Validation warning noted but output file contains expected data - proceeding")
        else:
            log(f"[VALIDATION] Result: {validation_result_2}")

        log("[SUCCESS] Step 03 complete - Age effects extracted with Bonferroni correction")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
