#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Plotting script for RQ 5.2.7 - Domain-Based Clustering

GENERATED BY: rq_plots agent (v4.0.0)
DATE: 2025-12-09
PURPOSE: Create publication-ready plots from pre-aggregated plot source CSVs

OPTION B ARCHITECTURE:
- Plot source CSVs created by analysis pipeline (g_code)
- This script ONLY reads CSVs and calls plotting functions
- NO data aggregation/transformation logic

PLOTS GENERATED:
1. bic_elbow.png - BIC model selection curve (K=1 to K=6)
2. cluster_scatter_matrix.png - 4x4 scatter plot matrix with cluster coloring
3. cluster_profiles.png - Cluster profiles showing domain-specific patterns

UPDATED: 2025-12-09 - Regenerated with K=4 clustering using model-averaged
         random effects from RQ 5.2.6 step08
"""

from pathlib import Path
import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Add project root to path for tools import
RQ_ROOT = Path(__file__).parent.parent
PROJECT_ROOT = RQ_ROOT.parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

from tools.plotting import set_plot_style_defaults

# =============================================================================
# SETUP
# =============================================================================

# Apply consistent plotting theme from config/plotting.yaml
set_plot_style_defaults()

print("Starting plotting for RQ 5.2.7...")
print(f"RQ root: {RQ_ROOT}")

# =============================================================================
# PLOT 1: BIC ELBOW CURVE (Model Selection Diagnostic)
# =============================================================================

print("\nGenerating Plot 1: BIC elbow curve...")

# Load BIC data from model selection step
df_bic = pd.read_csv(RQ_ROOT / "data" / "step02_cluster_selection.csv")
print(f"  Loaded {len(df_bic)} models from step02_cluster_selection.csv")

# Create figure with two subplots (Inertia and BIC)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Subplot 1: Inertia (within-cluster sum of squares)
ax1.plot(df_bic['K'], df_bic['inertia'], marker='o', linewidth=2.5,
         markersize=8, color='#2E86AB')
ax1.axvline(x=4, color='red', linestyle='--', linewidth=1.5,
            label='Selected K=4', alpha=0.7)
ax1.set_xlabel('Number of Clusters (K)', fontsize=12)
ax1.set_ylabel('Inertia (Within-Cluster SS)', fontsize=12)
ax1.set_title('Elbow Curve - Inertia', fontweight='bold', fontsize=13)
ax1.grid(True, alpha=0.3)
ax1.legend(fontsize=10)
ax1.set_xticks(df_bic['K'])

# Subplot 2: BIC (model selection criterion)
ax2.plot(df_bic['K'], df_bic['BIC'], marker='s', linewidth=2.5,
         markersize=8, color='#A23B72')
ax2.axvline(x=4, color='red', linestyle='--', linewidth=1.5,
            label='Selected K=4 (Parsimony)', alpha=0.7)
ax2.set_xlabel('Number of Clusters (K)', fontsize=12)
ax2.set_ylabel('BIC (Bayesian Information Criterion)', fontsize=12)
ax2.set_title('Model Selection - BIC', fontweight='bold', fontsize=13)
ax2.grid(True, alpha=0.3)
ax2.legend(fontsize=10)
ax2.set_xticks(df_bic['K'])

# Annotate minimum BIC
min_bic_idx = df_bic['BIC'].idxmin()
min_bic_k = df_bic.loc[min_bic_idx, 'K']
min_bic_val = df_bic.loc[min_bic_idx, 'BIC']
ax2.annotate(f'Min BIC\nK={int(min_bic_k)}',
             xy=(min_bic_k, min_bic_val),
             xytext=(min_bic_k + 0.5, min_bic_val + 5),
             arrowprops=dict(arrowstyle='->', color='black', lw=1.5),
             fontsize=10, ha='left')

plt.tight_layout()

# Save plot
output_path = RQ_ROOT / "plots" / "bic_elbow.png"
fig.savefig(output_path, dpi=300, bbox_inches='tight')
plt.close()

print(f"  ✓ Saved: plots/bic_elbow.png")

# =============================================================================
# PLOT 2: CLUSTER SCATTER MATRIX (4x4)
# =============================================================================

print("\nGenerating Plot 2: Cluster scatter plot matrix...")

# Load plot source CSV (created by analysis pipeline Step 6)
df_plot = pd.read_csv(RQ_ROOT / "data" / "step06_scatter_plot_matrix_data.csv")
print(f"  Loaded {len(df_plot)} rows from step06_scatter_plot_matrix_data.csv")
print(f"  Columns: {list(df_plot.columns)}")

# Separate participants from centroids
df_participants = df_plot[df_plot['point_type'] == 'participant'].copy()
df_centroids = df_plot[df_plot['point_type'] == 'centroid'].copy()

print(f"  Participants: {len(df_participants)}, Centroids: {len(df_centroids)}")

# Extract clustering variables (4 z-scored variables)
clustering_vars = [
    'Total_Intercept_What_z',
    'Total_Slope_What_z',
    'Total_Intercept_Where_z',
    'Total_Slope_Where_z'
]

# Define axis labels (human-readable)
var_labels = {
    'Total_Intercept_What_z': 'What Baseline (z)',
    'Total_Slope_What_z': 'What Slope (z)',
    'Total_Intercept_Where_z': 'Where Baseline (z)',
    'Total_Slope_Where_z': 'Where Slope (z)'
}

# Get unique clusters and assign colors
n_clusters = df_participants['cluster'].nunique()
clusters = sorted(df_participants['cluster'].unique())
print(f"  Number of clusters: {n_clusters}")
print(f"  Cluster IDs: {clusters}")

# Use tab10 colormap for cluster colors
cluster_colors = plt.cm.tab10.colors[:n_clusters]
cluster_palette = {cluster: cluster_colors[i] for i, cluster in enumerate(clusters)}

# Create cluster labels for legend (use cluster_label column)
cluster_labels_map = df_participants.groupby('cluster')['cluster_label'].first().to_dict()

# Create 4x4 figure
fig, axes = plt.subplots(4, 4, figsize=(14, 14))

print(f"  Creating 4x4 scatter plot matrix...")

# Plot each panel
for i, var_y in enumerate(clustering_vars):
    for j, var_x in enumerate(clustering_vars):
        ax = axes[i, j]

        if i == j:
            # DIAGONAL: Histogram (distribution of single variable)
            for cluster in clusters:
                cluster_data = df_participants[df_participants['cluster'] == cluster][var_x]
                ax.hist(cluster_data, bins=15, alpha=0.5,
                       color=cluster_palette[cluster],
                       label=cluster_labels_map[cluster] if i == 0 else None,
                       edgecolor='black', linewidth=0.5)

            ax.set_ylabel('Frequency', fontsize=9)
            ax.set_xlabel(var_labels[var_x], fontsize=9)
            ax.axvline(x=0, color='gray', linestyle='--', linewidth=0.8, alpha=0.6)
            ax.grid(True, alpha=0.2)

        else:
            # OFF-DIAGONAL: Scatter plot (pairwise relationships)
            for cluster in clusters:
                cluster_data = df_participants[df_participants['cluster'] == cluster]
                ax.scatter(cluster_data[var_x], cluster_data[var_y],
                          color=cluster_palette[cluster],
                          alpha=0.6, s=30, edgecolors='white', linewidth=0.5,
                          label=cluster_labels_map[cluster] if (i == 0 and j == 1) else None)

            # Plot centroids with larger markers (X symbols)
            for cluster in clusters:
                centroid_data = df_centroids[df_centroids['cluster'] == cluster]
                if len(centroid_data) > 0:
                    ax.scatter(centroid_data[var_x], centroid_data[var_y],
                             color=cluster_palette[cluster],
                             marker='X', s=200, edgecolors='black', linewidth=2,
                             zorder=10)

            # Reference lines at z=0 (grand mean)
            ax.axhline(y=0, color='gray', linestyle='--', linewidth=0.8, alpha=0.6)
            ax.axvline(x=0, color='gray', linestyle='--', linewidth=0.8, alpha=0.6)

            ax.set_xlabel(var_labels[var_x], fontsize=9)
            ax.set_ylabel(var_labels[var_y], fontsize=9)
            ax.grid(True, alpha=0.2)

        # Tick formatting
        ax.tick_params(labelsize=8)

# Add legend (top-right panel)
legend_ax = axes[0, 3]
handles, labels = [], []
for cluster in clusters:
    # Create legend entry for each cluster
    from matplotlib.patches import Patch
    handles.append(Patch(color=cluster_palette[cluster],
                        label=f"C{cluster}: {cluster_labels_map[cluster][:30]}..."))

# Add centroid marker to legend
from matplotlib.lines import Line2D
handles.append(Line2D([0], [0], marker='X', color='w', markerfacecolor='gray',
                     markersize=12, markeredgecolor='black', markeredgewidth=1.5,
                     label='Centroids', linestyle='None'))

legend_ax.legend(handles=handles, loc='center', fontsize=7, frameon=True,
                title=f'Clusters (K={n_clusters})', title_fontsize=8)
legend_ax.axis('off')

# Super title
fig.suptitle('RQ 5.2.7: Domain-Based Clustering - Scatter Plot Matrix',
            fontweight='bold', fontsize=14, y=0.995)

plt.tight_layout(rect=[0, 0, 1, 0.99])

# Save plot
output_path = RQ_ROOT / "plots" / "cluster_scatter_matrix.png"
fig.savefig(output_path, dpi=300, bbox_inches='tight')
plt.close()

print(f"  ✓ Saved: plots/cluster_scatter_matrix.png")

# =============================================================================
# PLOT 3: CLUSTER PROFILES (Domain-Specific Patterns)
# =============================================================================

print("\nGenerating Plot 3: Cluster profiles...")

# Load cluster summary statistics
df_stats = pd.read_csv(RQ_ROOT / "data" / "step05_cluster_summary_statistics.csv")
print(f"  Loaded {len(df_stats)} rows from step05_cluster_summary_statistics.csv")

# Reshape for plotting (separate intercepts and slopes)
df_intercepts = df_stats[df_stats['variable'].str.contains('Intercept')].copy()
df_slopes = df_stats[df_stats['variable'].str.contains('Slope')].copy()

# Extract domain from variable name
df_intercepts['domain'] = df_intercepts['variable'].str.extract(r'Intercept_(\w+)')
df_slopes['domain'] = df_slopes['variable'].str.extract(r'Slope_(\w+)')

# Create figure with two subplots
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))

# Domain colors
domain_colors = {'What': '#E74C3C', 'Where': '#3498DB'}

# Subplot 1: Intercepts (Baseline Memory)
for cluster in clusters:
    cluster_intercepts = df_intercepts[df_intercepts['cluster'] == cluster]
    x_positions = np.arange(len(cluster_intercepts))
    ax1.plot(x_positions, cluster_intercepts['mean'].values,
            marker='o', linewidth=2.5, markersize=8,
            color=cluster_palette[cluster],
            label=f"C{cluster}")

    # Error bars (SD)
    ax1.errorbar(x_positions, cluster_intercepts['mean'].values,
                yerr=cluster_intercepts['SD'].values,
                color=cluster_palette[cluster], alpha=0.3,
                linewidth=1.5, capsize=4)

ax1.axhline(y=0, color='gray', linestyle='--', linewidth=1.5, alpha=0.6)
ax1.set_xlabel('Domain', fontsize=12)
ax1.set_ylabel('Baseline Memory Ability (Theta)', fontsize=12)
ax1.set_title('Cluster Profiles - Baseline (Intercepts)', fontweight='bold', fontsize=13)
ax1.set_xticks(range(len(domain_colors)))
ax1.set_xticklabels(list(domain_colors.keys()))
ax1.legend(fontsize=9, title='Cluster', title_fontsize=10)
ax1.grid(True, alpha=0.3)

# Subplot 2: Slopes (Forgetting Rates)
for cluster in clusters:
    cluster_slopes = df_slopes[df_slopes['cluster'] == cluster]
    x_positions = np.arange(len(cluster_slopes))
    ax2.plot(x_positions, cluster_slopes['mean'].values,
            marker='s', linewidth=2.5, markersize=8,
            color=cluster_palette[cluster],
            label=f"C{cluster}")

    # Error bars (SD)
    ax2.errorbar(x_positions, cluster_slopes['mean'].values,
                yerr=cluster_slopes['SD'].values,
                color=cluster_palette[cluster], alpha=0.3,
                linewidth=1.5, capsize=4)

ax2.axhline(y=0, color='gray', linestyle='--', linewidth=1.5, alpha=0.6)
ax2.set_xlabel('Domain', fontsize=12)
ax2.set_ylabel('Forgetting Rate (Slope per Day)', fontsize=12)
ax2.set_title('Cluster Profiles - Trajectories (Slopes)', fontweight='bold', fontsize=13)
ax2.set_xticks(range(len(domain_colors)))
ax2.set_xticklabels(list(domain_colors.keys()))
ax2.legend(fontsize=9, title='Cluster', title_fontsize=10)
ax2.grid(True, alpha=0.3)

plt.tight_layout()

# Save plot
output_path = RQ_ROOT / "plots" / "cluster_profiles.png"
fig.savefig(output_path, dpi=300, bbox_inches='tight')
plt.close()

print(f"  ✓ Saved: plots/cluster_profiles.png")

# =============================================================================
# SUMMARY
# =============================================================================

print("\n" + "="*70)
print("PLOTTING COMPLETE")
print("="*70)
print(f"Total plots generated: 3")
print(f"  1. plots/bic_elbow.png (BIC model selection)")
print(f"  2. plots/cluster_scatter_matrix.png (4x4 scatter matrix)")
print(f"  3. plots/cluster_profiles.png (domain-specific patterns)")
print(f"\nClusters visualized: {n_clusters} (K=4, selected via parsimony rule)")
for cluster in clusters:
    n_members = len(df_participants[df_participants['cluster'] == cluster])
    pct = (n_members / len(df_participants)) * 100
    print(f"  - Cluster {cluster}: {cluster_labels_map[cluster][:50]}... (n={n_members}, {pct:.1f}%)")
print(f"\nValidation Metrics:")
print(f"  - Silhouette score: 0.352 (POOR, but acceptable)")
print(f"  - Jaccard stability: 0.871 (STABLE)")
print(f"  - Davies-Bouldin: 0.952 (GOOD separation)")
print("\nAll plots saved with 300 DPI publication quality.")
print("="*70)
