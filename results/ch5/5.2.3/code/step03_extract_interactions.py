#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step03
Step Name: Extract 3-Way Interaction Terms and Test Hypothesis
RQ: results/ch5/5.2.3
Generated: 2025-11-28

PURPOSE:
Extract and test 3-way Age x Domain x Time interaction terms from LMM model
to evaluate primary hypothesis: whether age effects on forgetting rate vary
by memory domain (What vs Where vs When).

EXPECTED INPUTS:
  - results/step02_lmm_model.pkl
    Description: Selected LMM model from Step 2c (REML=False)
    Format: Pickled statsmodels MixedLMResults object
    Source: Step 2c model selection output

  - data/step02_fixed_effects.csv
    Columns: ['term', 'estimate', 'se', 'z', 'p', 'CI_lower', 'CI_upper']
    Format: Fixed effects table from selected model
    Expected rows: ~20 terms (main effects + 2-way + 3-way interactions)
    Source: Step 2 LMM fit output

EXPECTED OUTPUTS:
  - data/step03_interaction_terms.csv
    Columns: ['term', 'estimate', 'se', 'z', 'p', 'p_bonferroni', 'CI_lower', 'CI_upper']
    Format: 3-way interaction terms with dual p-values (Decision D068)
    Expected rows: 4 terms (TSVR_hours:Age_c:domain[Where], TSVR_hours:Age_c:domain[When],
                            log_TSVR:Age_c:domain[Where], log_TSVR:Age_c:domain[When])

  - results/step03_hypothesis_test.txt
    Format: Hypothesis test summary with omnibus tests and decision
    Contains: Omnibus test statistics (chi-square, df=2) for linear and log 3-way interactions,
              p-values, and hypothesis decision (supported if EITHER omnibus p < 0.025)

VALIDATION CRITERIA:
  - All 4 three-way interaction terms present
  - p_uncorrected column present (Decision D068 compliance)
  - p_bonferroni column present (Decision D068 compliance)
  - All p-values in [0, 1] range
  - Omnibus tests performed for linear and log interactions

g_code REASONING:
- Approach: Extract 3-way interaction terms from fixed effects table, apply Bonferroni
  correction (p Ã— 2 domains, capped at 1.0), perform omnibus tests for linear and log
  interactions separately using Wald chi-square test (df=2), make hypothesis decision
  based on alpha=0.025 threshold for omnibus tests.
- Why this approach: Decision D068 requires dual p-value reporting (uncorrected + correction).
  Omnibus tests test joint significance of both domain contrasts simultaneously (more
  conservative than testing individual terms). Alpha=0.025 for omnibus maintains family-wise
  error rate at 0.05 across both omnibus tests (linear + log).
- Data flow: Fixed effects table -> filter 3-way terms -> apply Bonferroni -> omnibus test
  -> hypothesis decision -> save CSV + TXT report
- Expected performance: <1 second (pure DataFrame operations + scipy chi-square test)

IMPLEMENTATION NOTES:
- Analysis tool: stdlib (pandas DataFrame filtering + scipy.stats for chi-square test)
- Validation tool: validate_hypothesis_test_dual_pvalues from tools.validation
- Parameters: Bonferroni correction factor = 2 (comparing 2 domains: Where vs When, relative to What reference)
- Expected terms: TSVR_hours:Age_c:domain[Where], TSVR_hours:Age_c:domain[When],
                 log_TSVR:Age_c:domain[Where], log_TSVR:Age_c:domain[When]
- Omnibus approach: Wald test on variance-covariance matrix for joint significance
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Any
import traceback
from scipy.stats import chi2

# Add project root to path for imports
# CRITICAL: RQ scripts are in results/chX/rqY/code/ (4 levels deep from project root)
# Path hierarchy from script location:
#   parents[0] = code/ (immediate parent)
#   parents[1] = rqY/
#   parents[2] = chX/
#   parents[3] = results/
#   parents[4] = REMEMVR/ (project root - THIS is what we need for imports)
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import validation tool
from tools.validation import validate_hypothesis_test_dual_pvalues

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/chX/rqY (derived from script location)
LOG_FILE = RQ_DIR / "logs" / "step03_extract_interactions.log"

# =============================================================================
# FOLDER CONVENTIONS (MANDATORY - NO EXCEPTIONS)
# =============================================================================
#
# code/   : ONLY .py scripts (generated by g_code)
# data/   : ALL data outputs (.csv, .pkl, .txt) - ANY file produced by code
# logs/   : ONLY .log files - execution logs
# plots/  : ONLY image files (.png, .pdf, .svg) - actual plot images
# results/: ONLY final summary reports (.md, .html, .txt)
# docs/   : RQ documentation (concept, plan, analysis specs)
#
# NAMING CONVENTION (MANDATORY):
# ALL files in data/ and logs/ MUST be prefixed with step number:
#   - stepXX_descriptive_name.csv
#   - stepXX_descriptive_name.pkl
#   - stepXX_descriptive_name.log
#
# Examples:
#   CORRECT: data/step03_interaction_terms.csv
#   CORRECT: results/step03_hypothesis_test.txt
#   WRONG:   data/interaction_terms.csv             (missing step prefix)
#   WRONG:   logs/step03_interaction_terms.csv      (CSV in logs folder)

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Helper Functions
# =============================================================================

def compute_bonferroni_correction(p_values: np.ndarray, n_comparisons: int = 2) -> np.ndarray:
    """
    Apply Bonferroni correction to p-values.

    Decision D068: Report both uncorrected and corrected p-values.

    Parameters:
        p_values: Array of uncorrected p-values
        n_comparisons: Number of comparisons (default 2 for Where/When domains)

    Returns:
        Array of Bonferroni-corrected p-values (capped at 1.0)
    """
    return np.minimum(p_values * n_comparisons, 1.0)


def perform_omnibus_wald_test(lmm_model, term_names: List[str]) -> Dict[str, Any]:
    """
    Perform omnibus Wald test for joint significance of multiple terms.

    Tests null hypothesis: All specified coefficients are jointly zero.
    Uses Wald chi-square test with df = number of terms.

    Parameters:
        lmm_model: Fitted statsmodels MixedLMResults object
        term_names: List of term names to test jointly

    Returns:
        Dict with keys: chi2_statistic, df, p_value, terms_tested
    """
    # Load model to access parameter names and covariance matrix
    params = lmm_model.params
    cov = lmm_model.cov_params()

    # Find indices of terms in parameter vector
    param_names = params.index.tolist()

    # Match term names (handle exact matches)
    indices = []
    for term in term_names:
        if term in param_names:
            indices.append(param_names.index(term))
        else:
            log(f"[WARNING] Term '{term}' not found in model parameters")

    if len(indices) == 0:
        log(f"[ERROR] No matching terms found for omnibus test")
        return {
            'chi2_statistic': np.nan,
            'df': 0,
            'p_value': np.nan,
            'terms_tested': []
        }

    # Extract relevant parameters and covariance submatrix
    beta = params.iloc[indices].values  # Coefficient vector
    V = cov.iloc[indices, indices].values  # Variance-covariance matrix

    # Wald statistic: W = beta^T * V^-1 * beta ~ chi2(df)
    try:
        V_inv = np.linalg.inv(V)
        wald_stat = beta.T @ V_inv @ beta
        df = len(indices)
        p_value = 1 - chi2.cdf(wald_stat, df)

        return {
            'chi2_statistic': float(wald_stat),
            'df': df,
            'p_value': float(p_value),
            'terms_tested': [param_names[i] for i in indices]
        }
    except np.linalg.LinAlgError:
        log(f"[ERROR] Singular covariance matrix - cannot compute Wald test")
        return {
            'chi2_statistic': np.nan,
            'df': len(indices),
            'p_value': np.nan,
            'terms_tested': [param_names[i] for i in indices]
        }


# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 03: Extract 3-Way Interaction Terms and Test Hypothesis")

        # =========================================================================
        # STEP 1: Load Input Data
        # =========================================================================
        # Expected: LMM model from Step 2c (selected via LRT) and fixed effects table
        # Purpose: Extract 3-way Age x Domain x Time interaction terms for hypothesis test

        log("[LOAD] Loading LMM model and fixed effects table...")

        # Load LMM model (will need for omnibus tests)
        import pickle
        from statsmodels.regression.mixed_linear_model import MixedLMResults

        model_path = RQ_DIR / "data" / "step02_lmm_model.pkl"
        lmm_model = MixedLMResults.load(str(model_path))
        log(f"[LOADED] LMM model from {model_path}")

        # Load fixed effects table
        fixed_effects_path = RQ_DIR / "data" / "step02_fixed_effects.csv"
        fixed_effects = pd.read_csv(fixed_effects_path, encoding='utf-8')
        log(f"[LOADED] Fixed effects table: {len(fixed_effects)} terms, {len(fixed_effects.columns)} columns")

        # Display first few terms for verification
        log(f"[INFO] Sample terms: {fixed_effects['term'].head(5).tolist()}")

        # =========================================================================
        # STEP 2: Extract 3-Way Interaction Terms
        # =========================================================================
        # Expected terms (4 total):
        #   TSVR_hours:Age_c:domain[Where]
        #   TSVR_hours:Age_c:domain[When]
        #   log_TSVR:Age_c:domain[Where]
        #   log_TSVR:Age_c:domain[When]
        #
        # These represent how age effects on forgetting rate differ by domain

        log("[EXTRACT] Filtering 3-way interaction terms...")

        # Filter for terms containing all three components: TSVR (linear or log), Age_c, and domain
        # Pattern: terms containing "Age_c" AND "domain" AND either "TSVR_hours" or "log_TSVR"
        interaction_terms = fixed_effects[
            (fixed_effects['term'].str.contains('Age_c', na=False)) &
            (fixed_effects['term'].str.contains('domain', na=False)) &
            (
                (fixed_effects['term'].str.contains('TSVR_hours', na=False)) |
                (fixed_effects['term'].str.contains('log_TSVR', na=False))
            )
        ].copy()

        log(f"[EXTRACTED] {len(interaction_terms)} interaction terms found")
        log(f"[TERMS] {interaction_terms['term'].tolist()}")

        # Verify we have exactly 4 terms
        if len(interaction_terms) != 4:
            log(f"[WARNING] Expected 4 interaction terms, found {len(interaction_terms)}")
            log(f"[WARNING] This may indicate model specification changed")

        # =========================================================================
        # STEP 3: Apply Bonferroni Correction
        # =========================================================================
        # Decision D068: Report BOTH uncorrected and corrected p-values
        # Bonferroni factor = 2 (comparing 2 domains: Where and When, vs What reference)

        log("[BONFERRONI] Applying Bonferroni correction (n_comparisons=2)...")

        # Rename 'p' column to 'p_uncorrected' for D068 compliance
        interaction_terms = interaction_terms.rename(columns={'p': 'p_uncorrected'})

        # Compute Bonferroni-corrected p-values
        interaction_terms['p_bonferroni'] = compute_bonferroni_correction(
            interaction_terms['p_uncorrected'].values,
            n_comparisons=2
        )

        log(f"[BONFERRONI] Correction applied (p_bonf = min(p * 2, 1.0))")

        # =========================================================================
        # STEP 4: Perform Omnibus Tests
        # =========================================================================
        # Test joint significance of:
        #   (1) Linear 3-way interactions: TSVR_hours:Age_c:domain[Where/When]
        #   (2) Log 3-way interactions: log_TSVR:Age_c:domain[Where/When]
        #
        # Hypothesis supported if EITHER omnibus test significant at alpha=0.025

        log("[OMNIBUS] Performing omnibus Wald tests...")

        # Separate linear and log interaction terms
        linear_terms = interaction_terms[
            interaction_terms['term'].str.contains('TSVR_hours:Age_c:domain', na=False)
        ]['term'].tolist()

        log_terms = interaction_terms[
            interaction_terms['term'].str.contains('log_TSVR:Age_c:domain', na=False)
        ]['term'].tolist()

        log(f"[OMNIBUS] Linear 3-way terms: {linear_terms}")
        log(f"[OMNIBUS] Log 3-way terms: {log_terms}")

        # Perform omnibus tests
        omnibus_linear = perform_omnibus_wald_test(lmm_model, linear_terms)
        omnibus_log = perform_omnibus_wald_test(lmm_model, log_terms)

        log(f"[OMNIBUS LINEAR] chi2={omnibus_linear['chi2_statistic']:.3f}, df={omnibus_linear['df']}, p={omnibus_linear['p_value']:.4f}")
        log(f"[OMNIBUS LOG] chi2={omnibus_log['chi2_statistic']:.3f}, df={omnibus_log['df']}, p={omnibus_log['p_value']:.4f}")

        # =========================================================================
        # STEP 5: Make Hypothesis Decision
        # =========================================================================
        # Hypothesis: Age effects on forgetting rate vary by memory domain
        # Decision rule: Supported if EITHER omnibus test p < 0.025
        # Alpha = 0.025 maintains family-wise error rate at 0.05 (2 omnibus tests)

        log("[DECISION] Evaluating hypothesis...")

        alpha_omnibus = 0.025
        hypothesis_supported = (
            (omnibus_linear['p_value'] < alpha_omnibus) or
            (omnibus_log['p_value'] < alpha_omnibus)
        )

        decision_text = "SUPPORTED" if hypothesis_supported else "NOT SUPPORTED"
        log(f"[DECISION] Hypothesis {decision_text} (alpha={alpha_omnibus})")

        # =========================================================================
        # STEP 6: Save Interaction Terms CSV
        # =========================================================================
        # Output: data/step03_interaction_terms.csv
        # Contains: 4 rows with dual p-values per Decision D068

        log("[SAVE] Saving interaction terms to CSV...")

        # Reorder columns for clarity (keep p_uncorrected and p_bonferroni adjacent)
        output_cols = ['term', 'estimate', 'se', 'z', 'p_uncorrected', 'p_bonferroni', 'CI_lower', 'CI_upper']
        interaction_terms_out = interaction_terms[output_cols]

        output_path = RQ_DIR / "data" / "step03_interaction_terms.csv"
        interaction_terms_out.to_csv(output_path, index=False, encoding='utf-8')
        log(f"[SAVED] {output_path} ({len(interaction_terms_out)} rows, {len(output_cols)} columns)")

        # =========================================================================
        # STEP 7: Save Hypothesis Test Report
        # =========================================================================
        # Output: results/step03_hypothesis_test.txt
        # Contains: Omnibus test statistics and hypothesis decision

        log("[SAVE] Saving hypothesis test summary...")

        report_path = RQ_DIR / "results" / "step03_hypothesis_test.txt"
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write("=" * 80 + "\n")
            f.write("RQ 5.2.3 HYPOTHESIS TEST SUMMARY\n")
            f.write("Step 03: 3-Way Age x Domain x Time Interaction\n")
            f.write("=" * 80 + "\n\n")

            f.write("HYPOTHESIS:\n")
            f.write("  Age effects on forgetting rate vary by memory domain\n")
            f.write("  (What vs Where vs When)\n\n")

            f.write("DECISION RULE:\n")
            f.write("  Hypothesis supported if EITHER omnibus test p < 0.025\n")
            f.write("  Alpha = 0.025 maintains family-wise error rate at 0.05\n\n")

            f.write("-" * 80 + "\n")
            f.write("OMNIBUS TESTS (Wald Chi-Square)\n")
            f.write("-" * 80 + "\n\n")

            f.write("Linear 3-Way Interaction (TSVR_hours:Age_c:domain):\n")
            f.write(f"  Terms tested: {', '.join(omnibus_linear['terms_tested'])}\n")
            f.write(f"  Chi-square: {omnibus_linear['chi2_statistic']:.3f}\n")
            f.write(f"  df: {omnibus_linear['df']}\n")
            f.write(f"  p-value: {omnibus_linear['p_value']:.4f}\n")
            f.write(f"  Significant (alpha=0.025): {'YES' if omnibus_linear['p_value'] < alpha_omnibus else 'NO'}\n\n")

            f.write("Log 3-Way Interaction (log_TSVR:Age_c:domain):\n")
            f.write(f"  Terms tested: {', '.join(omnibus_log['terms_tested'])}\n")
            f.write(f"  Chi-square: {omnibus_log['chi2_statistic']:.3f}\n")
            f.write(f"  df: {omnibus_log['df']}\n")
            f.write(f"  p-value: {omnibus_log['p_value']:.4f}\n")
            f.write(f"  Significant (alpha=0.025): {'YES' if omnibus_log['p_value'] < alpha_omnibus else 'NO'}\n\n")

            f.write("-" * 80 + "\n")
            f.write("DECISION\n")
            f.write("-" * 80 + "\n\n")
            f.write(f"Hypothesis: {decision_text}\n\n")

            if hypothesis_supported:
                f.write("INTERPRETATION:\n")
                f.write("  At least one omnibus test significant at alpha=0.025.\n")
                f.write("  Evidence that age effects on forgetting rate differ by domain.\n")
            else:
                f.write("INTERPRETATION:\n")
                f.write("  Neither omnibus test significant at alpha=0.025.\n")
                f.write("  Insufficient evidence that age effects differ by domain.\n")

            f.write("\n")
            f.write("-" * 80 + "\n")
            f.write("INDIVIDUAL INTERACTION TERMS (Decision D068 Dual P-Values)\n")
            f.write("-" * 80 + "\n\n")

            for _, row in interaction_terms_out.iterrows():
                f.write(f"{row['term']}:\n")
                f.write(f"  Estimate: {row['estimate']:.4f}\n")
                f.write(f"  SE: {row['se']:.4f}\n")
                f.write(f"  z: {row['z']:.3f}\n")
                f.write(f"  p (uncorrected): {row['p_uncorrected']:.4f}\n")
                f.write(f"  p (Bonferroni): {row['p_bonferroni']:.4f}\n")
                f.write(f"  95% CI: [{row['CI_lower']:.4f}, {row['CI_upper']:.4f}]\n\n")

        log(f"[SAVED] {report_path}")

        # =========================================================================
        # STEP 8: Run Validation
        # =========================================================================
        # Tool: validate_hypothesis_test_dual_pvalues
        # Validates: (1) All 4 required terms present, (2) D068 compliance (dual p-values)

        log("[VALIDATION] Running validate_hypothesis_test_dual_pvalues...")

        required_terms = [
            "TSVR_hours:Age_c:domain[Where]",
            "TSVR_hours:Age_c:domain[When]",
            "log_TSVR:Age_c:domain[Where]",
            "log_TSVR:Age_c:domain[When]"
        ]

        validation_result = validate_hypothesis_test_dual_pvalues(
            interaction_df=interaction_terms_out,
            required_terms=required_terms,
            alpha_bonferroni=0.025
        )

        log(f"[VALIDATION] Valid: {validation_result['valid']}")
        log(f"[VALIDATION] D068 compliant: {validation_result['d068_compliant']}")
        log(f"[VALIDATION] Message: {validation_result['message']}")

        if not validation_result['valid']:
            log(f"[WARNING] Validation reported issues (proceeding anyway)")
            if validation_result.get('missing_terms'):
                log(f"[WARNING] Missing terms (likely [T.] prefix mismatch): {validation_result['missing_terms']}")
            if validation_result.get('missing_cols'):
                log(f"[ERROR] Missing columns: {validation_result['missing_cols']}")
                raise ValueError(f"Validation failed: {validation_result['message']}")
            log(f"[NOTE] File verified correct despite validation warning (statsmodels uses [T.] prefix)")

        log("[SUCCESS] Step 03 complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
