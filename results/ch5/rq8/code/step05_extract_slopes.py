#!/usr/bin/env python3
# =============================================================================
# SCRIPT METADATA (Generated by g_code)
# =============================================================================
"""
Step ID: step05
Step Name: Extract Slopes and Compute Ratio
RQ: results/ch5/rq8
Generated: 2025-11-28

PURPOSE:
Extract Early/Late segment slopes from piecewise LMM model with delta method SE
propagation for ratio computation. RQ 5.8 Test 4 requires Late/Early ratio < 0.5
to indicate robust two-phase forgetting pattern (consolidation-dominated Early
phase vs decay-dominated Late phase). Delta method required because ratio SE
cannot be computed via simple quadrature due to covariance between slopes.

EXPECTED INPUTS:
  - results/step03_piecewise_model_summary.txt
    Format: Pickled statsmodels MixedLMResults object (piecewise model)
    Expected: Model with Days_within:SegmentLate interaction term
    Source: Step 3 (piecewise LMM fitting)

EXPECTED OUTPUTS:
  - results/step05_slope_comparison.csv
    Columns: ['metric', 'value', 'SE', 'CI_lower', 'CI_upper', 'interpretation']
    Format: 4 rows (Early_slope, Late_slope, Ratio_Late_Early, Interaction_p)
    Expected rows: 4
    Description: Slope estimates with Late/Early ratio and interpretations

VALIDATION CRITERIA:
  - Early_slope in [-0.1, 0.0] (negative = forgetting)
  - Late_slope in [-0.05, 0.0] (negative, shallower than Early)
  - Ratio in [0, 2.0] (positive, typically <1.0)
  - Interaction_p in [0, 1]
  - No NaN, no Inf

g_code REASONING:
- Approach: Extract segment slopes from piecewise LMM fixed effects table
  - Early slope = beta_Days_within (Days_within main effect)
  - Late slope = beta_Days_within + beta_Days_within:SegmentLate (sum of main + interaction)
  - Ratio = Late_slope / Early_slope (with delta method SE propagation)
  - Interaction p-value = significance test for Days_within:SegmentLate term

- Why this approach:
  - Piecewise model formula: theta ~ Days_within + Days_within:SegmentLate + (Days_within | UID)
  - Interaction term tests if Late slope differs from Early slope (Test 2)
  - Ratio < 0.5 indicates robust two-phase pattern (convergent evidence, Test 4)
  - Delta method required for ratio SE (covariance between slopes affects uncertainty)

- Data flow:
  - Load piecewise model from Step 3 (pickled MixedLMResults)
  - Call extract_segment_slopes_from_lmm() with model object
  - Function extracts slopes, computes ratio with delta method SE
  - Save 4-row DataFrame with slope estimates and interpretations
  - Validate slope ranges and ratio bounds

- Expected performance: ~2 seconds (simple extraction from fitted model)

IMPLEMENTATION NOTES:
- Analysis tool: extract_segment_slopes_from_lmm from tools.analysis_lmm
- Validation tool: validate_numeric_range from tools.validation
- Parameters:
  - segment_col: "Segment" (segment variable name in model)
  - time_col: "Days_within" (time-within-segment variable)
  - ratio_threshold: 0.5 (robust two-phase threshold)
  - bonferroni_alpha: 0.003333 (Bonferroni correction for 15 Chapter 5 tests)
  - use_delta_method: True (SE propagation for ratio)
"""
# =============================================================================

import sys
from pathlib import Path
import pandas as pd
import numpy as np
import pickle
from typing import Dict, List, Tuple, Any
import traceback

# Add project root to path for imports
# CRITICAL: RQ scripts are in results/chX/rqY/code/ (4 levels deep from project root)
# Path hierarchy from script location:
#   parents[0] = code/ (immediate parent)
#   parents[1] = rqY/
#   parents[2] = chX/
#   parents[3] = results/
#   parents[4] = REMEMVR/ (project root - THIS is what we need for imports)
PROJECT_ROOT = Path(__file__).resolve().parents[4]
sys.path.insert(0, str(PROJECT_ROOT))

# Import analysis tool
from tools.analysis_lmm import extract_segment_slopes_from_lmm

# Import validation tool
from tools.validation import validate_numeric_range

# =============================================================================
# Configuration
# =============================================================================

RQ_DIR = Path(__file__).resolve().parents[1]  # results/chX/rqY (derived from script location)
LOG_FILE = RQ_DIR / "logs" / "step05_extract_slopes.log"

# =============================================================================
# FOLDER CONVENTIONS (MANDATORY - NO EXCEPTIONS)
# =============================================================================
#
# code/   : ONLY .py scripts (generated by g_code)
# data/   : ALL data outputs (.csv, .pkl, .txt) - ANY file produced by code
# logs/   : ONLY .log files - execution logs
# plots/  : ONLY image files (.png, .pdf, .svg) - actual plot images
# results/: ONLY final summary reports (.md, .html)
# docs/   : RQ documentation (concept, plan, analysis specs)
#
# NAMING CONVENTION (MANDATORY):
# ALL files in data/ and logs/ MUST be prefixed with step number:
#   - stepXX_descriptive_name.csv
#   - stepXX_descriptive_name.pkl
#   - stepXX_descriptive_name.log
#
# Examples:
#   CORRECT: data/step05_slope_comparison.csv
#   CORRECT: data/step03_theta_scores.csv
#   WRONG:   results/slope_comparison.csv  (wrong folder + no prefix)
#   WRONG:   data/slope_comparison.csv     (missing step prefix)
#   WRONG:   logs/step05_slopes.csv        (CSV in logs folder)

# =============================================================================
# Logging Function
# =============================================================================

def log(msg):
    """Write to both log file and console."""
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{msg}\n")
    print(msg)

# =============================================================================
# Main Analysis
# =============================================================================

if __name__ == "__main__":
    try:
        log("[START] Step 05: Extract Slopes and Compute Ratio")

        # =========================================================================
        # STEP 1: Load Piecewise Model (from Step 3)
        # =========================================================================
        # Expected: Pickled statsmodels MixedLMResults object
        # Purpose: Extract segment slopes from fitted piecewise LMM
        # Formula: theta ~ Days_within + Days_within:SegmentLate + (Days_within | UID)

        log("[LOAD] Loading piecewise model from Step 3...")

        # CRITICAL: Use MixedLMResults.load() method, NOT pickle.load()
        # pickle.load() causes patsy/eval errors with statsmodels models
        from statsmodels.regression.mixed_linear_model import MixedLMResults

        piecewise_model_path = RQ_DIR / "data" / "step03_piecewise_model.pkl"

        if not piecewise_model_path.exists():
            raise FileNotFoundError(
                f"Piecewise model not found: {piecewise_model_path}\n"
                f"Expected: Step 3 must complete before Step 5\n"
                f"Run step03_fit_piecewise_model.py first"
            )

        piecewise_model = MixedLMResults.load(str(piecewise_model_path))
        log(f"[LOADED] Piecewise model from {piecewise_model_path}")
        log(f"[INFO] Model converged: {piecewise_model.converged}")
        log(f"[INFO] AIC: {piecewise_model.aic:.2f}")

        # =========================================================================
        # STEP 2: Extract Segment Slopes with Delta Method SE Propagation
        # =========================================================================
        # Tool: extract_segment_slopes_from_lmm
        # What it does:
        #   - Extracts Early slope (beta_Days_within)
        #   - Extracts Late slope (beta_Days_within + beta_Days_within:SegmentLate)
        #   - Computes Late/Early ratio with delta method SE propagation
        #   - Extracts interaction p-value (Days_within:SegmentLate significance)
        # Expected output: DataFrame with 4 rows (Early, Late, Ratio, Interaction_p)

        log("[ANALYSIS] Extracting segment slopes and computing ratio...")

        slope_comparison = extract_segment_slopes_from_lmm(
            lmm_result=piecewise_model,
            segment_col="Segment",       # Segment variable name in piecewise model
            time_col="Days_within"       # Time-within-segment variable name
        )

        log("[DONE] Slope extraction complete")
        log(f"[INFO] Extracted {len(slope_comparison)} metrics:")
        for idx, row in slope_comparison.iterrows():
            log(f"  - {row['metric']}: {row['value']:.6f}")

        # =========================================================================
        # STEP 3: Save Slope Comparison Results
        # =========================================================================
        # Output: results/step05_slope_comparison.csv
        # Contains:
        #   - Early_slope: forgetting rate in Early segment (0-48h)
        #   - Late_slope: forgetting rate in Late segment (48-240h)
        #   - Ratio_Late_Early: Late/Early ratio (Test 4 convergent evidence)
        #   - Interaction_p: significance of Days_within:SegmentLate interaction
        # Downstream usage: Step 6 (plot data preparation), final interpretation

        log(f"[SAVE] Saving slope comparison to results/step05_slope_comparison.csv...")
        output_path = RQ_DIR / "results" / "step05_slope_comparison.csv"
        slope_comparison.to_csv(output_path, index=False, encoding='utf-8')
        log(f"[SAVED] {output_path} ({len(slope_comparison)} rows, {len(slope_comparison.columns)} cols)")

        # Log interpretations for human review
        log("[INTERPRETATIONS]")
        for idx, row in slope_comparison.iterrows():
            if pd.notna(row.get('interpretation')):
                log(f"  {row['metric']}: {row['interpretation']}")

        # =========================================================================
        # STEP 4: Validate Slope Estimates and Ratio Bounds
        # =========================================================================
        # Tool: validate_numeric_range
        # Validates:
        #   - Early_slope in [-0.1, 0.0] (negative = forgetting)
        #   - Late_slope in [-0.05, 0.0] (shallower than Early)
        #   - Ratio in [0, 2.0] (positive, typically <1.0 for two-phase)
        #   - Interaction_p in [0, 1]
        # Threshold: Ratio < 0.5 indicates robust two-phase forgetting

        log("[VALIDATION] Validating slope ranges and ratio bounds...")

        # Define expected ranges per metric
        expected_ranges = {
            'Early_slope': (-0.1, 0.0),
            'Late_slope': (-0.05, 0.0),
            'Ratio_Late_Early': (0.0, 2.0),
            'Interaction_p': (0.0, 1.0)
        }

        all_valid = True
        for idx, row in slope_comparison.iterrows():
            metric = row['metric']
            value = row['value']

            if metric in expected_ranges:
                min_val, max_val = expected_ranges[metric]

                # Validate range
                validation_result = validate_numeric_range(
                    data=pd.Series([value]),
                    min_val=min_val,
                    max_val=max_val,
                    column_name=metric
                )

                if validation_result['valid']:
                    log(f"[PASS] {metric}: {value:.6f} in [{min_val}, {max_val}]")
                else:
                    log(f"[FAIL] {metric}: {validation_result['message']}")
                    all_valid = False

        # Check for NaN or Inf
        if slope_comparison['value'].isna().any():
            log("[FAIL] NaN values detected in slope comparison")
            all_valid = False

        if np.isinf(slope_comparison['value']).any():
            log("[FAIL] Infinite values detected in slope comparison")
            all_valid = False

        if all_valid:
            log("[VALIDATION PASS] All slope estimates and ratio within expected bounds")
        else:
            raise ValueError("Validation failed: slope estimates or ratio out of bounds")

        # Interpret ratio for two-phase forgetting test
        ratio_row = slope_comparison[slope_comparison['metric'] == 'Ratio_Late_Early']
        if not ratio_row.empty:
            ratio_value = ratio_row.iloc[0]['value']
            if ratio_value < 0.5:
                log(f"[INTERPRETATION] Ratio = {ratio_value:.3f} < 0.5 -> ROBUST two-phase forgetting")
            elif ratio_value < 0.75:
                log(f"[INTERPRETATION] Ratio = {ratio_value:.3f} in [0.5, 0.75) -> MODERATE two-phase")
            elif ratio_value < 1.0:
                log(f"[INTERPRETATION] Ratio = {ratio_value:.3f} in [0.75, 1.0) -> WEAK two-phase")
            else:
                log(f"[INTERPRETATION] Ratio = {ratio_value:.3f} >= 1.0 -> UNEXPECTED (reverse pattern)")

        log("[SUCCESS] Step 05 complete")
        sys.exit(0)

    except Exception as e:
        log(f"[ERROR] {str(e)}")
        log("[TRACEBACK] Full error details:")
        with open(LOG_FILE, 'a', encoding='utf-8') as f:
            traceback.print_exc(file=f)
        traceback.print_exc()
        sys.exit(1)
